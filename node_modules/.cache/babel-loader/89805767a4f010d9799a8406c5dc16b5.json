{"ast":null,"code":"/*!\nFullCalendar Resources Common Plugin v4.2.0\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2019 Adam Shaw\n*/\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core')) : typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], factory) : (global = global || self, factory(global.FullCalendarResourceCommon = {}, global.FullCalendar));\n})(this, function (exports, core) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  var __assign = function () {\n    __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n\n  var ResourceDataAdder =\n  /** @class */\n  function () {\n    function ResourceDataAdder() {\n      this.filterResources = core.memoize(filterResources);\n    }\n\n    ResourceDataAdder.prototype.transform = function (viewProps, viewSpec, calendarProps, view) {\n      if (viewSpec.class.needsResourceData) {\n        return {\n          resourceStore: this.filterResources(calendarProps.resourceStore, view.opt('filterResourcesWithEvents'), calendarProps.eventStore, calendarProps.dateProfile.activeRange),\n          resourceEntityExpansions: calendarProps.resourceEntityExpansions\n        };\n      }\n    };\n\n    return ResourceDataAdder;\n  }();\n\n  function filterResources(resourceStore, doFilterResourcesWithEvents, eventStore, activeRange) {\n    if (doFilterResourcesWithEvents) {\n      var instancesInRange = filterEventInstancesInRange(eventStore.instances, activeRange);\n      var hasEvents_1 = computeHasEvents(instancesInRange, eventStore.defs);\n\n      __assign(hasEvents_1, computeAncestorHasEvents(hasEvents_1, resourceStore));\n\n      return core.filterHash(resourceStore, function (resource, resourceId) {\n        return hasEvents_1[resourceId];\n      });\n    } else {\n      return resourceStore;\n    }\n  }\n\n  function filterEventInstancesInRange(eventInstances, activeRange) {\n    return core.filterHash(eventInstances, function (eventInstance) {\n      return core.rangesIntersect(eventInstance.range, activeRange);\n    });\n  }\n\n  function computeHasEvents(eventInstances, eventDefs) {\n    var hasEvents = {};\n\n    for (var instanceId in eventInstances) {\n      var instance = eventInstances[instanceId];\n\n      for (var _i = 0, _a = eventDefs[instance.defId].resourceIds; _i < _a.length; _i++) {\n        var resourceId = _a[_i];\n        hasEvents[resourceId] = true;\n      }\n    }\n\n    return hasEvents;\n  }\n  /*\n  mark resources as having events if any of their ancestors have them\n  NOTE: resourceStore might not have all the resources that hasEvents{} has keyed\n  */\n\n\n  function computeAncestorHasEvents(hasEvents, resourceStore) {\n    var res = {};\n\n    for (var resourceId in hasEvents) {\n      var resource = void 0;\n\n      while (resource = resourceStore[resourceId]) {\n        resourceId = resource.parentId; // now functioning as the parentId\n\n        if (resourceId) {\n          res[resourceId] = true;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return res;\n  } // for when non-resource view should be given EventUi info (for event coloring/constraints based off of resource data)\n\n\n  var ResourceEventConfigAdder =\n  /** @class */\n  function () {\n    function ResourceEventConfigAdder() {\n      this.buildResourceEventUis = core.memoizeOutput(buildResourceEventUis, core.isPropsEqual);\n      this.injectResourceEventUis = core.memoize(injectResourceEventUis);\n    }\n\n    ResourceEventConfigAdder.prototype.transform = function (viewProps, viewSpec, calendarProps) {\n      if (!viewSpec.class.needsResourceData) {\n        // is a non-resource view?\n        return {\n          eventUiBases: this.injectResourceEventUis(viewProps.eventUiBases, viewProps.eventStore.defs, this.buildResourceEventUis(calendarProps.resourceStore))\n        };\n      }\n    };\n\n    return ResourceEventConfigAdder;\n  }();\n\n  function buildResourceEventUis(resourceStore) {\n    return core.mapHash(resourceStore, function (resource) {\n      return resource.ui;\n    });\n  }\n\n  function injectResourceEventUis(eventUiBases, eventDefs, resourceEventUis) {\n    return core.mapHash(eventUiBases, function (eventUi, defId) {\n      if (defId) {\n        // not the '' key\n        return injectResourceEventUi(eventUi, eventDefs[defId], resourceEventUis);\n      } else {\n        return eventUi;\n      }\n    });\n  }\n\n  function injectResourceEventUi(origEventUi, eventDef, resourceEventUis) {\n    var parts = []; // first resource takes precedence, which fights with the ordering of combineEventUis, thus the unshifts\n\n    for (var _i = 0, _a = eventDef.resourceIds; _i < _a.length; _i++) {\n      var resourceId = _a[_i];\n\n      if (resourceEventUis[resourceId]) {\n        parts.unshift(resourceEventUis[resourceId]);\n      }\n    }\n\n    parts.unshift(origEventUi);\n    return core.combineEventUis(parts);\n  }\n\n  var RESOURCE_SOURCE_PROPS = {\n    id: String\n  };\n  var defs = [];\n  var uid = 0;\n\n  function registerResourceSourceDef(def) {\n    defs.push(def);\n  }\n\n  function getResourceSourceDef(id) {\n    return defs[id];\n  }\n\n  function doesSourceIgnoreRange(source) {\n    return Boolean(defs[source.sourceDefId].ignoreRange);\n  }\n\n  function parseResourceSource(input) {\n    for (var i = defs.length - 1; i >= 0; i--) {\n      // later-added plugins take precedence\n      var def = defs[i];\n      var meta = def.parseMeta(input);\n\n      if (meta) {\n        var res = parseResourceSourceProps(typeof input === 'object' && input ? input : {}, meta, i);\n        res._raw = input;\n        return res;\n      }\n    }\n\n    return null;\n  }\n\n  function parseResourceSourceProps(input, meta, sourceDefId) {\n    var props = core.refineProps(input, RESOURCE_SOURCE_PROPS);\n    props.sourceId = String(uid++);\n    props.sourceDefId = sourceDefId;\n    props.meta = meta;\n    props.publicId = props.id;\n    props.isFetching = false;\n    props.latestFetchId = '';\n    props.fetchRange = null;\n    delete props.id;\n    return props;\n  }\n\n  function reduceResourceSource(source, action, dateProfile, calendar) {\n    switch (action.type) {\n      case 'INIT':\n        return createSource(calendar.opt('resources'), calendar);\n\n      case 'RESET_RESOURCE_SOURCE':\n        return createSource(action.resourceSourceInput, calendar, true);\n\n      case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n      case 'NEXT':\n      case 'SET_DATE':\n      case 'SET_VIEW_TYPE':\n        return handleRange(source, dateProfile.activeRange, calendar);\n\n      case 'RECEIVE_RESOURCES':\n      case 'RECEIVE_RESOURCE_ERROR':\n        return receiveResponse(source, action.fetchId, action.fetchRange);\n\n      case 'REFETCH_RESOURCES':\n        return fetchSource(source, dateProfile.activeRange, calendar);\n\n      default:\n        return source;\n    }\n  }\n\n  var uid$1 = 0;\n\n  function createSource(input, calendar, forceFetch) {\n    if (input) {\n      var source = parseResourceSource(input);\n\n      if (forceFetch || !calendar.opt('refetchResourcesOnNavigate')) {\n        // because assumes handleRange will do it later\n        source = fetchSource(source, null, calendar);\n      }\n\n      return source;\n    }\n\n    return null;\n  }\n\n  function handleRange(source, activeRange, calendar) {\n    if (calendar.opt('refetchResourcesOnNavigate') && !doesSourceIgnoreRange(source) && (!source.fetchRange || !core.rangesEqual(source.fetchRange, activeRange))) {\n      return fetchSource(source, activeRange, calendar);\n    } else {\n      return source;\n    }\n  }\n\n  function fetchSource(source, fetchRange, calendar) {\n    var sourceDef = getResourceSourceDef(source.sourceDefId);\n    var fetchId = String(uid$1++);\n    sourceDef.fetch({\n      resourceSource: source,\n      calendar: calendar,\n      range: fetchRange\n    }, function (res) {\n      // HACK\n      // do before calling dispatch in case dispatch renders synchronously\n      calendar.afterSizingTriggers._resourcesRendered = [null]; // fire once\n\n      calendar.dispatch({\n        type: 'RECEIVE_RESOURCES',\n        fetchId: fetchId,\n        fetchRange: fetchRange,\n        rawResources: res.rawResources\n      });\n    }, function (error) {\n      calendar.dispatch({\n        type: 'RECEIVE_RESOURCE_ERROR',\n        fetchId: fetchId,\n        fetchRange: fetchRange,\n        error: error\n      });\n    });\n    return __assign({}, source, {\n      isFetching: true,\n      latestFetchId: fetchId\n    });\n  }\n\n  function receiveResponse(source, fetchId, fetchRange) {\n    if (fetchId === source.latestFetchId) {\n      return __assign({}, source, {\n        isFetching: false,\n        fetchRange: fetchRange\n      });\n    }\n\n    return source;\n  }\n\n  var RESOURCE_PROPS = {\n    id: String,\n    title: String,\n    parentId: String,\n    businessHours: null,\n    children: null,\n    extendedProps: null\n  };\n  var PRIVATE_ID_PREFIX = '_fc:';\n  var uid$2 = 0;\n  /*\n  needs a full store so that it can populate children too\n  */\n\n  function parseResource(input, parentId, store, calendar) {\n    if (parentId === void 0) {\n      parentId = '';\n    }\n\n    var leftovers0 = {};\n    var props = core.refineProps(input, RESOURCE_PROPS, {}, leftovers0);\n    var leftovers1 = {};\n    var ui = core.processScopedUiProps('event', leftovers0, calendar, leftovers1);\n\n    if (!props.id) {\n      props.id = PRIVATE_ID_PREFIX + uid$2++;\n    }\n\n    if (!props.parentId) {\n      // give precedence to the parentId property\n      props.parentId = parentId;\n    }\n\n    props.businessHours = props.businessHours ? core.parseBusinessHours(props.businessHours, calendar) : null;\n    props.ui = ui;\n    props.extendedProps = __assign({}, leftovers1, props.extendedProps); // help out ResourceApi from having user modify props\n\n    Object.freeze(ui.classNames);\n    Object.freeze(props.extendedProps);\n    if (store[props.id]) ;else {\n      store[props.id] = props;\n\n      if (props.children) {\n        for (var _i = 0, _a = props.children; _i < _a.length; _i++) {\n          var childInput = _a[_i];\n          parseResource(childInput, props.id, store, calendar);\n        }\n\n        delete props.children;\n      }\n    }\n    return props;\n  }\n  /*\n  TODO: use this in more places\n  */\n\n\n  function getPublicId(id) {\n    if (id.indexOf(PRIVATE_ID_PREFIX) === 0) {\n      return '';\n    }\n\n    return id;\n  }\n\n  function reduceResourceStore(store, action, source, calendar) {\n    switch (action.type) {\n      case 'INIT':\n        return {};\n\n      case 'RECEIVE_RESOURCES':\n        return receiveRawResources(store, action.rawResources, action.fetchId, source, calendar);\n\n      case 'ADD_RESOURCE':\n        return addResource(store, action.resourceHash);\n\n      case 'REMOVE_RESOURCE':\n        return removeResource(store, action.resourceId);\n\n      case 'SET_RESOURCE_PROP':\n        return setResourceProp(store, action.resourceId, action.propName, action.propValue);\n\n      case 'RESET_RESOURCES':\n        // must make the calendar think each resource is a new object :/\n        return core.mapHash(store, function (resource) {\n          return __assign({}, resource);\n        });\n\n      default:\n        return store;\n    }\n  }\n\n  function receiveRawResources(existingStore, inputs, fetchId, source, calendar) {\n    if (source.latestFetchId === fetchId) {\n      var nextStore = {};\n\n      for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n        var input = inputs_1[_i];\n        parseResource(input, '', nextStore, calendar);\n      }\n\n      return nextStore;\n    } else {\n      return existingStore;\n    }\n  }\n\n  function addResource(existingStore, additions) {\n    // TODO: warn about duplicate IDs\n    return __assign({}, existingStore, additions);\n  }\n\n  function removeResource(existingStore, resourceId) {\n    var newStore = __assign({}, existingStore);\n\n    delete newStore[resourceId]; // promote children\n\n    for (var childResourceId in newStore) {\n      // a child, *maybe* but probably not\n      if (newStore[childResourceId].parentId === resourceId) {\n        newStore[childResourceId] = __assign({}, newStore[childResourceId], {\n          parentId: ''\n        });\n      }\n    }\n\n    return newStore;\n  }\n\n  function setResourceProp(existingStore, resourceId, name, value) {\n    var _a, _b;\n\n    var existingResource = existingStore[resourceId]; // TODO: sanitization\n\n    if (existingResource) {\n      return __assign({}, existingStore, (_a = {}, _a[resourceId] = __assign({}, existingResource, (_b = {}, _b[name] = value, _b)), _a));\n    } else {\n      return existingStore;\n    }\n  }\n\n  function reduceResourceEntityExpansions(expansions, action) {\n    var _a;\n\n    switch (action.type) {\n      case 'INIT':\n        return {};\n\n      case 'SET_RESOURCE_ENTITY_EXPANDED':\n        return __assign({}, expansions, (_a = {}, _a[action.id] = action.isExpanded, _a));\n\n      default:\n        return expansions;\n    }\n  }\n\n  function resourcesReducers(state, action, calendar) {\n    var resourceSource = reduceResourceSource(state.resourceSource, action, state.dateProfile, calendar);\n    var resourceStore = reduceResourceStore(state.resourceStore, action, resourceSource, calendar);\n    var resourceEntityExpansions = reduceResourceEntityExpansions(state.resourceEntityExpansions, action);\n    return __assign({}, state, {\n      resourceSource: resourceSource,\n      resourceStore: resourceStore,\n      resourceEntityExpansions: resourceEntityExpansions\n    });\n  }\n\n  var RESOURCE_RELATED_PROPS = {\n    resourceId: String,\n    resourceIds: function (items) {\n      return (items || []).map(function (item) {\n        return String(item);\n      });\n    },\n    resourceEditable: Boolean\n  };\n\n  function parseEventDef(def, props, leftovers) {\n    var resourceRelatedProps = core.refineProps(props, RESOURCE_RELATED_PROPS, {}, leftovers);\n    var resourceIds = resourceRelatedProps.resourceIds;\n\n    if (resourceRelatedProps.resourceId) {\n      resourceIds.push(resourceRelatedProps.resourceId);\n    }\n\n    def.resourceIds = resourceIds;\n    def.resourceEditable = resourceRelatedProps.resourceEditable;\n  }\n\n  function massageEventDragMutation(eventMutation, hit0, hit1) {\n    var resource0 = hit0.dateSpan.resourceId;\n    var resource1 = hit1.dateSpan.resourceId;\n\n    if (resource0 && resource1 && resource0 !== resource1) {\n      eventMutation.resourceMutation = {\n        matchResourceId: resource0,\n        setResourceId: resource1\n      };\n    }\n  }\n  /*\n  TODO: all this would be much easier if we were using a hash!\n  */\n\n\n  function applyEventDefMutation(eventDef, mutation, calendar) {\n    var resourceMutation = mutation.resourceMutation;\n\n    if (resourceMutation && computeResourceEditable(eventDef, calendar)) {\n      var index = eventDef.resourceIds.indexOf(resourceMutation.matchResourceId);\n\n      if (index !== -1) {\n        var resourceIds = eventDef.resourceIds.slice(); // copy\n\n        resourceIds.splice(index, 1); // remove\n\n        if (resourceIds.indexOf(resourceMutation.setResourceId) === -1) {\n          // not already in there\n          resourceIds.push(resourceMutation.setResourceId); // add\n        }\n\n        eventDef.resourceIds = resourceIds;\n      }\n    }\n  }\n  /*\n  HACK\n  TODO: use EventUi system instead of this\n  */\n\n\n  function computeResourceEditable(eventDef, calendar) {\n    var resourceEditable = eventDef.resourceEditable;\n\n    if (resourceEditable == null) {\n      var source = eventDef.sourceId && calendar.state.eventSources[eventDef.sourceId];\n\n      if (source) {\n        resourceEditable = source.extendedProps.resourceEditable; // used the Source::extendedProps hack\n      }\n\n      if (resourceEditable == null) {\n        resourceEditable = calendar.opt('eventResourceEditable');\n\n        if (resourceEditable == null) {\n          resourceEditable = calendar.opt('editable'); // TODO: use defaults system instead\n        }\n      }\n    }\n\n    return resourceEditable;\n  }\n\n  function transformEventDrop(mutation, calendar) {\n    var resourceMutation = mutation.resourceMutation;\n\n    if (resourceMutation) {\n      return {\n        oldResource: calendar.getResourceById(resourceMutation.matchResourceId),\n        newResource: calendar.getResourceById(resourceMutation.setResourceId)\n      };\n    } else {\n      return {\n        oldResource: null,\n        newResource: null\n      };\n    }\n  }\n\n  function transformDateSelectionJoin(hit0, hit1) {\n    var resourceId0 = hit0.dateSpan.resourceId;\n    var resourceId1 = hit1.dateSpan.resourceId;\n\n    if (resourceId0 && resourceId1) {\n      if (hit0.component.allowAcrossResources === false && resourceId0 !== resourceId1) {\n        return false;\n      } else {\n        return {\n          resourceId: resourceId0\n        };\n      }\n    }\n  }\n\n  var ResourceApi =\n  /** @class */\n  function () {\n    function ResourceApi(calendar, rawResource) {\n      this._calendar = calendar;\n      this._resource = rawResource;\n    }\n\n    ResourceApi.prototype.setProp = function (name, value) {\n      this._calendar.dispatch({\n        type: 'SET_RESOURCE_PROP',\n        resourceId: this._resource.id,\n        propName: name,\n        propValue: value\n      });\n    };\n\n    ResourceApi.prototype.remove = function () {\n      this._calendar.dispatch({\n        type: 'REMOVE_RESOURCE',\n        resourceId: this._resource.id\n      });\n    };\n\n    ResourceApi.prototype.getParent = function () {\n      var calendar = this._calendar;\n      var parentId = this._resource.parentId;\n\n      if (parentId) {\n        return new ResourceApi(calendar, calendar.state.resourceSource[parentId]);\n      } else {\n        return null;\n      }\n    };\n\n    ResourceApi.prototype.getChildren = function () {\n      var thisResourceId = this._resource.id;\n      var calendar = this._calendar;\n      var resourceStore = calendar.state.resourceStore;\n      var childApis = [];\n\n      for (var resourceId in resourceStore) {\n        if (resourceStore[resourceId].parentId === thisResourceId) {\n          childApis.push(new ResourceApi(calendar, resourceStore[resourceId]));\n        }\n      }\n\n      return childApis;\n    };\n    /*\n    this is really inefficient!\n    TODO: make EventApi::resourceIds a hash or keep an index in the Calendar's state\n    */\n\n\n    ResourceApi.prototype.getEvents = function () {\n      var thisResourceId = this._resource.id;\n      var calendar = this._calendar;\n      var _a = calendar.state.eventStore,\n          defs = _a.defs,\n          instances = _a.instances;\n      var eventApis = [];\n\n      for (var instanceId in instances) {\n        var instance = instances[instanceId];\n        var def = defs[instance.defId];\n\n        if (def.resourceIds.indexOf(thisResourceId) !== -1) {\n          // inefficient!!!\n          eventApis.push(new core.EventApi(calendar, def, instance));\n        }\n      }\n\n      return eventApis;\n    };\n\n    Object.defineProperty(ResourceApi.prototype, \"id\", {\n      get: function () {\n        return this._resource.id;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"title\", {\n      get: function () {\n        return this._resource.title;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventConstraint\", {\n      get: function () {\n        return this._resource.ui.constraints[0] || null;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventOverlap\", {\n      get: function () {\n        return this._resource.ui.overlap;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventAllow\", {\n      get: function () {\n        return this._resource.ui.allows[0] || null;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventBackgroundColor\", {\n      get: function () {\n        return this._resource.ui.backgroundColor;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventBorderColor\", {\n      get: function () {\n        return this._resource.ui.borderColor;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventTextColor\", {\n      get: function () {\n        return this._resource.ui.textColor;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"eventClassNames\", {\n      // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n      get: function () {\n        return this._resource.ui.classNames;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    Object.defineProperty(ResourceApi.prototype, \"extendedProps\", {\n      get: function () {\n        return this._resource.extendedProps;\n      },\n      enumerable: true,\n      configurable: true\n    });\n    return ResourceApi;\n  }();\n\n  core.Calendar.prototype.addResource = function (input, scrollTo) {\n    var _a;\n\n    if (scrollTo === void 0) {\n      scrollTo = true;\n    }\n\n    var resourceHash;\n    var resource;\n\n    if (input instanceof ResourceApi) {\n      resource = input._resource;\n      resourceHash = (_a = {}, _a[resource.id] = resource, _a);\n    } else {\n      resourceHash = {};\n      resource = parseResource(input, '', resourceHash, this);\n    } // HACK\n\n\n    if (scrollTo) {\n      this.component.view.addScroll({\n        forcedRowId: resource.id\n      });\n    }\n\n    this.dispatch({\n      type: 'ADD_RESOURCE',\n      resourceHash: resourceHash\n    });\n    return new ResourceApi(this, resource);\n  };\n\n  core.Calendar.prototype.getResourceById = function (id) {\n    id = String(id);\n\n    if (this.state.resourceStore) {\n      // guard against calendar with no resource functionality\n      var rawResource = this.state.resourceStore[id];\n\n      if (rawResource) {\n        return new ResourceApi(this, rawResource);\n      }\n    }\n\n    return null;\n  };\n\n  core.Calendar.prototype.getResources = function () {\n    var resourceStore = this.state.resourceStore;\n    var resourceApis = [];\n\n    if (resourceStore) {\n      // guard against calendar with no resource functionality\n      for (var resourceId in resourceStore) {\n        resourceApis.push(new ResourceApi(this, resourceStore[resourceId]));\n      }\n    }\n\n    return resourceApis;\n  };\n\n  core.Calendar.prototype.getTopLevelResources = function () {\n    var resourceStore = this.state.resourceStore;\n    var resourceApis = [];\n\n    if (resourceStore) {\n      // guard against calendar with no resource functionality\n      for (var resourceId in resourceStore) {\n        if (!resourceStore[resourceId].parentId) {\n          resourceApis.push(new ResourceApi(this, resourceStore[resourceId]));\n        }\n      }\n    }\n\n    return resourceApis;\n  };\n\n  core.Calendar.prototype.rerenderResources = function () {\n    this.dispatch({\n      type: 'RESET_RESOURCES'\n    });\n  };\n\n  core.Calendar.prototype.refetchResources = function () {\n    this.dispatch({\n      type: 'REFETCH_RESOURCES'\n    });\n  };\n\n  function transformDatePoint(dateSpan, calendar) {\n    return dateSpan.resourceId ? {\n      resource: calendar.getResourceById(dateSpan.resourceId)\n    } : {};\n  }\n\n  function transformDateSpan(dateSpan, calendar) {\n    return dateSpan.resourceId ? {\n      resource: calendar.getResourceById(dateSpan.resourceId)\n    } : {};\n  }\n  /*\n  splits things BASED OFF OF which resources they are associated with.\n  creates a '' entry which is when something has NO resource.\n  */\n\n\n  var ResourceSplitter =\n  /** @class */\n  function (_super) {\n    __extends(ResourceSplitter, _super);\n\n    function ResourceSplitter() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    ResourceSplitter.prototype.getKeyInfo = function (props) {\n      return __assign({\n        '': {}\n      }, props.resourceStore // already has `ui` and `businessHours` keys!\n      );\n    };\n\n    ResourceSplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n      return [dateSpan.resourceId || ''];\n    };\n\n    ResourceSplitter.prototype.getKeysForEventDef = function (eventDef) {\n      var resourceIds = eventDef.resourceIds;\n\n      if (!resourceIds.length) {\n        return [''];\n      }\n\n      return resourceIds;\n    };\n\n    return ResourceSplitter;\n  }(core.Splitter);\n\n  function isPropsValidWithResources(props, calendar) {\n    var splitter = new ResourceSplitter();\n    var sets = splitter.splitProps(__assign({}, props, {\n      resourceStore: calendar.state.resourceStore\n    }));\n\n    for (var resourceId in sets) {\n      var props_1 = sets[resourceId]; // merge in event data from the non-resource segment\n\n      if (resourceId && sets['']) {\n        // current segment is not the non-resource one, and there IS a non-resource one\n        props_1 = __assign({}, props_1, {\n          eventStore: core.mergeEventStores(sets[''].eventStore, props_1.eventStore),\n          eventUiBases: __assign({}, sets[''].eventUiBases, props_1.eventUiBases)\n        });\n      }\n\n      if (!core.isPropsValid(props_1, calendar, {\n        resourceId: resourceId\n      }, filterConfig.bind(null, resourceId))) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function filterConfig(resourceId, config) {\n    return __assign({}, config, {\n      constraints: filterConstraints(resourceId, config.constraints)\n    });\n  }\n\n  function filterConstraints(resourceId, constraints) {\n    return constraints.map(function (constraint) {\n      var defs = constraint.defs;\n\n      if (defs) {\n        // we are dealing with an EventStore\n        // if any of the events define constraints to resources that are NOT this resource,\n        // then this resource is unconditionally prohibited, which is what a `false` value does.\n        for (var defId in defs) {\n          var resourceIds = defs[defId].resourceIds;\n\n          if (resourceIds.length && resourceIds.indexOf(resourceId) === -1) {\n            // TODO: use a hash?!!! (for other reasons too)\n            return false;\n          }\n        }\n      }\n\n      return constraint;\n    });\n  }\n\n  function transformExternalDef(dateSpan) {\n    return dateSpan.resourceId ? {\n      resourceId: dateSpan.resourceId\n    } : {};\n  }\n\n  function transformEventResizeJoin(hit0, hit1) {\n    var component = hit0.component;\n\n    if (component.allowAcrossResources === false && hit0.dateSpan.resourceId !== hit1.dateSpan.resourceId) {\n      return false;\n    }\n  }\n\n  core.EventApi.prototype.getResources = function () {\n    var calendar = this._calendar;\n    return this._def.resourceIds.map(function (resourceId) {\n      return calendar.getResourceById(resourceId);\n    });\n  };\n\n  core.EventApi.prototype.setResources = function (resources) {\n    var resourceIds = []; // massage resources -> resourceIds\n\n    for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {\n      var resource = resources_1[_i];\n      var resourceId = null;\n\n      if (typeof resource === 'string') {\n        resourceId = resource;\n      } else if (typeof resource === 'number') {\n        resourceId = String(resource);\n      } else if (resource instanceof ResourceApi) {\n        resourceId = resource.id; // guaranteed to always have an ID. hmmm\n      } else {\n        console.warn('unknown resource type: ' + resource);\n      }\n\n      if (resourceId) {\n        resourceIds.push(resourceId);\n      }\n    }\n\n    this.mutate({\n      standardProps: {\n        resourceIds: resourceIds\n      }\n    });\n  };\n\n  var RELEASE_DATE = '2019-06-02'; // for Scheduler\n\n  var UPGRADE_WINDOW = 365 + 7; // days. 1 week leeway, for tz shift reasons too\n\n  var LICENSE_INFO_URL = 'http://fullcalendar.io/scheduler/license/';\n  var PRESET_LICENSE_KEYS = ['GPL-My-Project-Is-Open-Source', 'CC-Attribution-NonCommercial-NoDerivatives'];\n  var CSS = {\n    position: 'absolute',\n    'z-index': 99999,\n    bottom: '1px',\n    left: '1px',\n    background: '#eee',\n    'border-color': '#ddd',\n    'border-style': 'solid',\n    'border-width': '1px 1px 0 0',\n    padding: '2px 4px',\n    'font-size': '12px',\n    'border-top-right-radius': '3px'\n  };\n\n  function injectLicenseWarning(containerEl, calendar) {\n    var key = calendar.opt('schedulerLicenseKey');\n\n    if (!isImmuneUrl(window.location.href) && !isValidKey(key)) {\n      core.appendToElement(containerEl, '<div class=\"fc-license-message\" style=\"' + core.htmlEscape(core.cssToStr(CSS)) + '\">' + 'Please use a valid license key. <a href=\"' + LICENSE_INFO_URL + '\">More Info</a>' + '</div>');\n    }\n  }\n  /*\n  This decryption is not meant to be bulletproof. Just a way to remind about an upgrade.\n  */\n\n\n  function isValidKey(key) {\n    if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {\n      return true;\n    }\n\n    var parts = (key || '').match(/^(\\d+)\\-fcs\\-(\\d+)$/);\n\n    if (parts && parts[1].length === 10) {\n      var purchaseDate = new Date(parseInt(parts[2], 10) * 1000);\n      var releaseDate = new Date(core.config.mockSchedulerReleaseDate || RELEASE_DATE);\n\n      if (core.isValidDate(releaseDate)) {\n        // token won't be replaced in dev mode\n        var minPurchaseDate = core.addDays(releaseDate, -UPGRADE_WINDOW);\n\n        if (minPurchaseDate < purchaseDate) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  function isImmuneUrl(url) {\n    return /\\w+\\:\\/\\/fullcalendar\\.io\\/|\\/demos\\/[\\w-]+\\.html$/.test(url);\n  }\n\n  var optionChangeHandlers = {\n    resources: handleResources\n  };\n\n  function handleResources(newSourceInput, calendar, deepEquals) {\n    var oldSourceInput = calendar.state.resourceSource._raw;\n\n    if (!deepEquals(oldSourceInput, newSourceInput)) {\n      calendar.dispatch({\n        type: 'RESET_RESOURCE_SOURCE',\n        resourceSourceInput: newSourceInput\n      });\n    }\n  }\n\n  registerResourceSourceDef({\n    ignoreRange: true,\n    parseMeta: function (raw) {\n      if (Array.isArray(raw)) {\n        return raw;\n      } else if (Array.isArray(raw.resources)) {\n        return raw.resources;\n      }\n\n      return null;\n    },\n    fetch: function (arg, successCallback) {\n      successCallback({\n        rawResources: arg.resourceSource.meta\n      });\n    }\n  });\n  registerResourceSourceDef({\n    parseMeta: function (raw) {\n      if (typeof raw === 'function') {\n        return raw;\n      } else if (typeof raw.resources === 'function') {\n        return raw.resources;\n      }\n\n      return null;\n    },\n    fetch: function (arg, success, failure) {\n      var dateEnv = arg.calendar.dateEnv;\n      var func = arg.resourceSource.meta;\n      var publicArg = {};\n\n      if (arg.range) {\n        publicArg = {\n          start: dateEnv.toDate(arg.range.start),\n          end: dateEnv.toDate(arg.range.end),\n          startStr: dateEnv.formatIso(arg.range.start),\n          endStr: dateEnv.formatIso(arg.range.end),\n          timeZone: dateEnv.timeZone\n        };\n      } // TODO: make more dry with EventSourceFunc\n      // TODO: accept a response?\n\n\n      core.unpromisify(func.bind(null, publicArg), function (rawResources) {\n        success({\n          rawResources: rawResources\n        }); // needs an object response\n      }, failure // send errorObj directly to failure callback\n      );\n    }\n  });\n  registerResourceSourceDef({\n    parseMeta: function (raw) {\n      if (typeof raw === 'string') {\n        raw = {\n          url: raw\n        };\n      } else if (!raw || typeof raw !== 'object' || !raw.url) {\n        return null;\n      }\n\n      return {\n        url: raw.url,\n        method: (raw.method || 'GET').toUpperCase(),\n        extraParams: raw.extraParams\n      };\n    },\n    fetch: function (arg, successCallback, failureCallback) {\n      var meta = arg.resourceSource.meta;\n      var requestParams = buildRequestParams(meta, arg.range, arg.calendar);\n      core.requestJson(meta.method, meta.url, requestParams, function (rawResources, xhr) {\n        successCallback({\n          rawResources: rawResources,\n          xhr: xhr\n        });\n      }, function (message, xhr) {\n        failureCallback({\n          message: message,\n          xhr: xhr\n        });\n      });\n    }\n  }); // TODO: somehow consolidate with event json feed\n\n  function buildRequestParams(meta, range, calendar) {\n    var dateEnv = calendar.dateEnv;\n    var startParam;\n    var endParam;\n    var timeZoneParam;\n    var customRequestParams;\n    var params = {};\n\n    if (range) {\n      // startParam = meta.startParam\n      // if (startParam == null) {\n      startParam = calendar.opt('startParam'); // }\n      // endParam = meta.endParam\n      // if (endParam == null) {\n\n      endParam = calendar.opt('endParam'); // }\n      // timeZoneParam = meta.timeZoneParam\n      // if (timeZoneParam == null) {\n\n      timeZoneParam = calendar.opt('timeZoneParam'); // }\n\n      params[startParam] = dateEnv.formatIso(range.start);\n      params[endParam] = dateEnv.formatIso(range.end);\n\n      if (dateEnv.timeZone !== 'local') {\n        params[timeZoneParam] = dateEnv.timeZone;\n      }\n    } // retrieve any outbound GET/POST data from the options\n\n\n    if (typeof meta.extraParams === 'function') {\n      // supplied as a function that returns a key/value object\n      customRequestParams = meta.extraParams();\n    } else {\n      // probably supplied as a straight key/value object\n      customRequestParams = meta.extraParams || {};\n    }\n\n    __assign(params, customRequestParams);\n\n    return params;\n  }\n\n  function buildResourceTextFunc(resourceTextSetting, calendar) {\n    if (typeof resourceTextSetting === 'function') {\n      return function (resource) {\n        return resourceTextSetting(new ResourceApi(calendar, resource));\n      };\n    } else {\n      return function (resource) {\n        return resource.title || getPublicId(resource.id);\n      };\n    }\n  }\n\n  var ResourceDayHeader =\n  /** @class */\n  function (_super) {\n    __extends(ResourceDayHeader, _super);\n\n    function ResourceDayHeader(context, parentEl) {\n      var _this = _super.call(this, context) || this;\n\n      _this.datesAboveResources = _this.opt('datesAboveResources');\n      _this.resourceTextFunc = buildResourceTextFunc(_this.opt('resourceText'), _this.calendar);\n      parentEl.innerHTML = ''; // because might be nbsp\n\n      parentEl.appendChild(_this.el = core.htmlToElement('<div class=\"fc-row ' + _this.theme.getClass('headerRow') + '\">' + '<table class=\"' + _this.theme.getClass('tableGrid') + '\">' + '<thead></thead>' + '</table>' + '</div>'));\n      _this.thead = _this.el.querySelector('thead');\n      return _this;\n    }\n\n    ResourceDayHeader.prototype.destroy = function () {\n      core.removeElement(this.el);\n    };\n\n    ResourceDayHeader.prototype.render = function (props) {\n      var html;\n      this.dateFormat = core.createFormatter(this.opt('columnHeaderFormat') || core.computeFallbackHeaderFormat(props.datesRepDistinctDays, props.dates.length));\n\n      if (props.dates.length === 1) {\n        html = this.renderResourceRow(props.resources);\n      } else {\n        if (this.datesAboveResources) {\n          html = this.renderDayAndResourceRows(props.dates, props.resources);\n        } else {\n          html = this.renderResourceAndDayRows(props.resources, props.dates);\n        }\n      }\n\n      this.thead.innerHTML = html;\n      this.processResourceEls(props.resources);\n    };\n\n    ResourceDayHeader.prototype.renderResourceRow = function (resources) {\n      var _this = this;\n\n      var cellHtmls = resources.map(function (resource) {\n        return _this.renderResourceCell(resource, 1);\n      });\n      return this.buildTr(cellHtmls);\n    };\n\n    ResourceDayHeader.prototype.renderDayAndResourceRows = function (dates, resources) {\n      var dateHtmls = [];\n      var resourceHtmls = [];\n\n      for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {\n        var date = dates_1[_i];\n        dateHtmls.push(this.renderDateCell(date, resources.length));\n\n        for (var _a = 0, resources_1 = resources; _a < resources_1.length; _a++) {\n          var resource = resources_1[_a];\n          resourceHtmls.push(this.renderResourceCell(resource, 1, date));\n        }\n      }\n\n      return this.buildTr(dateHtmls) + this.buildTr(resourceHtmls);\n    };\n\n    ResourceDayHeader.prototype.renderResourceAndDayRows = function (resources, dates) {\n      var resourceHtmls = [];\n      var dateHtmls = [];\n\n      for (var _i = 0, resources_2 = resources; _i < resources_2.length; _i++) {\n        var resource = resources_2[_i];\n        resourceHtmls.push(this.renderResourceCell(resource, dates.length));\n\n        for (var _a = 0, dates_2 = dates; _a < dates_2.length; _a++) {\n          var date = dates_2[_a];\n          dateHtmls.push(this.renderDateCell(date, 1, resource));\n        }\n      }\n\n      return this.buildTr(resourceHtmls) + this.buildTr(dateHtmls);\n    }; // Cell Rendering Utils\n    // ----------------------------------------------------------------------------------------------\n    // a cell with the resource name. might be associated with a specific day\n\n\n    ResourceDayHeader.prototype.renderResourceCell = function (resource, colspan, date) {\n      var dateEnv = this.dateEnv;\n      return '<th class=\"fc-resource-cell\"' + ' data-resource-id=\"' + resource.id + '\"' + (date ? ' data-date=\"' + dateEnv.formatIso(date, {\n        omitTime: true\n      }) + '\"' : '') + (colspan > 1 ? ' colspan=\"' + colspan + '\"' : '') + '>' + core.htmlEscape(this.resourceTextFunc(resource)) + '</th>';\n    }; // a cell with date text. might have a resource associated with it\n\n\n    ResourceDayHeader.prototype.renderDateCell = function (date, colspan, resource) {\n      var props = this.props;\n      return core.renderDateCell(date, props.dateProfile, props.datesRepDistinctDays, props.dates.length * props.resources.length, this.dateFormat, this.context, colspan, resource ? 'data-resource-id=\"' + resource.id + '\"' : '');\n    };\n\n    ResourceDayHeader.prototype.buildTr = function (cellHtmls) {\n      if (!cellHtmls.length) {\n        cellHtmls = ['<td>&nbsp;</td>'];\n      }\n\n      if (this.props.renderIntroHtml) {\n        cellHtmls = [this.props.renderIntroHtml()].concat(cellHtmls);\n      }\n\n      if (this.isRtl) {\n        cellHtmls.reverse();\n      }\n\n      return '<tr>' + cellHtmls.join('') + '</tr>';\n    }; // Post-rendering\n    // ----------------------------------------------------------------------------------------------\n    // given a container with already rendered resource cells\n\n\n    ResourceDayHeader.prototype.processResourceEls = function (resources) {\n      var _this = this;\n\n      var view = this.view;\n      core.findElements(this.thead, '.fc-resource-cell').forEach(function (node, col) {\n        col = col % resources.length;\n\n        if (_this.isRtl) {\n          col = resources.length - 1 - col;\n        }\n\n        var resource = resources[col];\n        view.publiclyTrigger('resourceRender', [{\n          resource: new ResourceApi(_this.calendar, resource),\n          el: node,\n          view: view\n        }]);\n      });\n    };\n\n    return ResourceDayHeader;\n  }(core.Component);\n\n  var AbstractResourceDayTable =\n  /** @class */\n  function () {\n    function AbstractResourceDayTable(dayTable, resources) {\n      this.dayTable = dayTable;\n      this.resources = resources;\n      this.resourceIndex = new ResourceIndex(resources);\n      this.rowCnt = dayTable.rowCnt;\n      this.colCnt = dayTable.colCnt * resources.length;\n      this.cells = this.buildCells();\n    }\n\n    AbstractResourceDayTable.prototype.buildCells = function () {\n      var _a = this,\n          rowCnt = _a.rowCnt,\n          dayTable = _a.dayTable,\n          resources = _a.resources;\n\n      var rows = [];\n\n      for (var row = 0; row < rowCnt; row++) {\n        var rowCells = [];\n\n        for (var dateCol = 0; dateCol < dayTable.colCnt; dateCol++) {\n          for (var resourceCol = 0; resourceCol < resources.length; resourceCol++) {\n            var resource = resources[resourceCol];\n            var htmlAttrs = 'data-resource-id=\"' + resource.id + '\"';\n            rowCells[this.computeCol(dateCol, resourceCol)] = {\n              date: dayTable.cells[row][dateCol].date,\n              resource: resource,\n              htmlAttrs: htmlAttrs\n            };\n          }\n        }\n\n        rows.push(rowCells);\n      }\n\n      return rows;\n    };\n\n    return AbstractResourceDayTable;\n  }();\n  /*\n  resources over dates\n  */\n\n\n  var ResourceDayTable =\n  /** @class */\n  function (_super) {\n    __extends(ResourceDayTable, _super);\n\n    function ResourceDayTable() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    ResourceDayTable.prototype.computeCol = function (dateI, resourceI) {\n      return resourceI * this.dayTable.colCnt + dateI;\n    };\n    /*\n    all date ranges are intact\n    */\n\n\n    ResourceDayTable.prototype.computeColRanges = function (dateStartI, dateEndI, resourceI) {\n      return [{\n        firstCol: this.computeCol(dateStartI, resourceI),\n        lastCol: this.computeCol(dateEndI, resourceI),\n        isStart: true,\n        isEnd: true\n      }];\n    };\n\n    return ResourceDayTable;\n  }(AbstractResourceDayTable);\n  /*\n  dates over resources\n  */\n\n\n  var DayResourceTable =\n  /** @class */\n  function (_super) {\n    __extends(DayResourceTable, _super);\n\n    function DayResourceTable() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    DayResourceTable.prototype.computeCol = function (dateI, resourceI) {\n      return dateI * this.resources.length + resourceI;\n    };\n    /*\n    every single day is broken up\n    */\n\n\n    DayResourceTable.prototype.computeColRanges = function (dateStartI, dateEndI, resourceI) {\n      var segs = [];\n\n      for (var i = dateStartI; i <= dateEndI; i++) {\n        var col = this.computeCol(i, resourceI);\n        segs.push({\n          firstCol: col,\n          lastCol: col,\n          isStart: i === dateStartI,\n          isEnd: i === dateEndI\n        });\n      }\n\n      return segs;\n    };\n\n    return DayResourceTable;\n  }(AbstractResourceDayTable);\n\n  var ResourceIndex =\n  /** @class */\n  function () {\n    function ResourceIndex(resources) {\n      var indicesById = {};\n      var ids = [];\n\n      for (var i = 0; i < resources.length; i++) {\n        var id = resources[i].id;\n        ids.push(id);\n        indicesById[id] = i;\n      }\n\n      this.ids = ids;\n      this.indicesById = indicesById;\n      this.length = resources.length;\n    }\n\n    return ResourceIndex;\n  }();\n  /*\n  TODO: just use ResourceHash somehow? could then use the generic ResourceSplitter\n  */\n\n\n  var VResourceSplitter =\n  /** @class */\n  function (_super) {\n    __extends(VResourceSplitter, _super);\n\n    function VResourceSplitter() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    VResourceSplitter.prototype.getKeyInfo = function (props) {\n      var resourceDayTable = props.resourceDayTable;\n      var hash = core.mapHash(resourceDayTable.resourceIndex.indicesById, function (i) {\n        return resourceDayTable.resources[i]; // has `ui` AND `businessHours` keys!\n      }); // :(\n\n      hash[''] = {};\n      return hash;\n    };\n\n    VResourceSplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n      return [dateSpan.resourceId || ''];\n    };\n\n    VResourceSplitter.prototype.getKeysForEventDef = function (eventDef) {\n      var resourceIds = eventDef.resourceIds;\n\n      if (!resourceIds.length) {\n        return [''];\n      }\n\n      return resourceIds;\n    };\n\n    return VResourceSplitter;\n  }(core.Splitter); // joiner\n\n\n  var NO_SEGS = []; // for memoizing\n\n  var VResourceJoiner =\n  /** @class */\n  function () {\n    function VResourceJoiner() {\n      this.joinDateSelection = core.memoize(this.joinSegs);\n      this.joinBusinessHours = core.memoize(this.joinSegs);\n      this.joinFgEvents = core.memoize(this.joinSegs);\n      this.joinBgEvents = core.memoize(this.joinSegs);\n      this.joinEventDrags = core.memoize(this.joinInteractions);\n      this.joinEventResizes = core.memoize(this.joinInteractions);\n    }\n    /*\n    propSets also has a '' key for things with no resource\n    */\n\n\n    VResourceJoiner.prototype.joinProps = function (propSets, resourceDayTable) {\n      var dateSelectionSets = [];\n      var businessHoursSets = [];\n      var fgEventSets = [];\n      var bgEventSets = [];\n      var eventDrags = [];\n      var eventResizes = [];\n      var eventSelection = '';\n      var keys = resourceDayTable.resourceIndex.ids.concat(['']); // add in the all-resource key\n\n      for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n        var key = keys_1[_i];\n        var props = propSets[key];\n        dateSelectionSets.push(props.dateSelectionSegs);\n        businessHoursSets.push(key ? props.businessHourSegs : NO_SEGS); // don't include redundant all-resource businesshours\n\n        fgEventSets.push(key ? props.fgEventSegs : NO_SEGS); // don't include fg all-resource segs\n\n        bgEventSets.push(props.bgEventSegs);\n        eventDrags.push(props.eventDrag);\n        eventResizes.push(props.eventResize);\n        eventSelection = eventSelection || props.eventSelection;\n      }\n\n      return {\n        dateSelectionSegs: this.joinDateSelection.apply(this, [resourceDayTable].concat(dateSelectionSets)),\n        businessHourSegs: this.joinBusinessHours.apply(this, [resourceDayTable].concat(businessHoursSets)),\n        fgEventSegs: this.joinFgEvents.apply(this, [resourceDayTable].concat(fgEventSets)),\n        bgEventSegs: this.joinBgEvents.apply(this, [resourceDayTable].concat(bgEventSets)),\n        eventDrag: this.joinEventDrags.apply(this, [resourceDayTable].concat(eventDrags)),\n        eventResize: this.joinEventResizes.apply(this, [resourceDayTable].concat(eventResizes)),\n        eventSelection: eventSelection\n      };\n    };\n\n    VResourceJoiner.prototype.joinSegs = function (resourceDayTable) {\n      var segGroups = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        segGroups[_i - 1] = arguments[_i];\n      }\n\n      var resourceCnt = resourceDayTable.resources.length;\n      var transformedSegs = [];\n\n      for (var i = 0; i < resourceCnt; i++) {\n        for (var _a = 0, _b = segGroups[i]; _a < _b.length; _a++) {\n          var seg = _b[_a];\n          transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));\n        }\n\n        for (var _c = 0, _d = segGroups[resourceCnt]; _c < _d.length; _c++) {\n          // one beyond. the all-resource\n          var seg = _d[_c];\n          transformedSegs.push.apply( // one beyond. the all-resource\n          transformedSegs, this.transformSeg(seg, resourceDayTable, i));\n        }\n      }\n\n      return transformedSegs;\n    };\n    /*\n    for expanding non-resource segs to all resources.\n    only for public use.\n    no memoizing.\n    */\n\n\n    VResourceJoiner.prototype.expandSegs = function (resourceDayTable, segs) {\n      var resourceCnt = resourceDayTable.resources.length;\n      var transformedSegs = [];\n\n      for (var i = 0; i < resourceCnt; i++) {\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n          var seg = segs_1[_i];\n          transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));\n        }\n      }\n\n      return transformedSegs;\n    };\n\n    VResourceJoiner.prototype.joinInteractions = function (resourceDayTable) {\n      var interactions = [];\n\n      for (var _i = 1; _i < arguments.length; _i++) {\n        interactions[_i - 1] = arguments[_i];\n      }\n\n      var resourceCnt = resourceDayTable.resources.length;\n      var affectedInstances = {};\n      var transformedSegs = [];\n      var isEvent = false;\n      var sourceSeg = null;\n\n      for (var i = 0; i < resourceCnt; i++) {\n        var interaction = interactions[i];\n\n        if (interaction) {\n          for (var _a = 0, _b = interaction.segs; _a < _b.length; _a++) {\n            var seg = _b[_a];\n            transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i) // TODO: templateify Interaction::segs\n            );\n          }\n\n          __assign(affectedInstances, interaction.affectedInstances);\n\n          isEvent = isEvent || interaction.isEvent;\n          sourceSeg = sourceSeg || interaction.sourceSeg;\n        }\n\n        if (interactions[resourceCnt]) {\n          // one beyond. the all-resource\n          for (var _c = 0, _d = interactions[resourceCnt].segs; _c < _d.length; _c++) {\n            var seg = _d[_c];\n            transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i) // TODO: templateify Interaction::segs\n            );\n          }\n        }\n      }\n\n      return {\n        affectedInstances: affectedInstances,\n        segs: transformedSegs,\n        isEvent: isEvent,\n        sourceSeg: sourceSeg\n      };\n    };\n\n    return VResourceJoiner;\n  }();\n  /*\n  doesn't accept grouping\n  */\n\n\n  function flattenResources(resourceStore, orderSpecs) {\n    return buildRowNodes(resourceStore, [], orderSpecs, false, {}, true).map(function (node) {\n      return node.resource;\n    });\n  }\n\n  function buildRowNodes(resourceStore, groupSpecs, orderSpecs, isVGrouping, expansions, expansionDefault) {\n    var complexNodes = buildHierarchy(resourceStore, isVGrouping ? -1 : 1, groupSpecs, orderSpecs);\n    var flatNodes = [];\n    flattenNodes(complexNodes, flatNodes, isVGrouping, [], 0, expansions, expansionDefault);\n    return flatNodes;\n  }\n\n  function flattenNodes(complexNodes, res, isVGrouping, rowSpans, depth, expansions, expansionDefault) {\n    for (var i = 0; i < complexNodes.length; i++) {\n      var complexNode = complexNodes[i];\n      var group = complexNode.group;\n\n      if (group) {\n        if (isVGrouping) {\n          var firstRowIndex = res.length;\n          var rowSpanIndex = rowSpans.length;\n          flattenNodes(complexNode.children, res, isVGrouping, rowSpans.concat(0), depth, expansions, expansionDefault);\n\n          if (firstRowIndex < res.length) {\n            var firstRow = res[firstRowIndex];\n            var firstRowSpans = firstRow.rowSpans = firstRow.rowSpans.slice();\n            firstRowSpans[rowSpanIndex] = res.length - firstRowIndex;\n          }\n        } else {\n          var id = group.spec.field + ':' + group.value;\n          var isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;\n          res.push({\n            id: id,\n            group: group,\n            isExpanded: isExpanded\n          });\n\n          if (isExpanded) {\n            flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);\n          }\n        }\n      } else if (complexNode.resource) {\n        var id = complexNode.resource.id;\n        var isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;\n        res.push({\n          id: id,\n          rowSpans: rowSpans,\n          depth: depth,\n          isExpanded: isExpanded,\n          hasChildren: Boolean(complexNode.children.length),\n          resource: complexNode.resource,\n          resourceFields: complexNode.resourceFields\n        });\n\n        if (isExpanded) {\n          flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);\n        }\n      }\n    }\n  }\n\n  function buildHierarchy(resourceStore, maxDepth, groupSpecs, orderSpecs) {\n    var resourceNodes = buildResourceNodes(resourceStore, orderSpecs);\n    var builtNodes = [];\n\n    for (var resourceId in resourceNodes) {\n      var resourceNode = resourceNodes[resourceId];\n\n      if (!resourceNode.resource.parentId) {\n        insertResourceNode(resourceNode, builtNodes, groupSpecs, 0, maxDepth, orderSpecs);\n      }\n    }\n\n    return builtNodes;\n  }\n\n  function buildResourceNodes(resourceStore, orderSpecs) {\n    var nodeHash = {};\n\n    for (var resourceId in resourceStore) {\n      var resource = resourceStore[resourceId];\n      nodeHash[resourceId] = {\n        resource: resource,\n        resourceFields: buildResourceFields(resource),\n        children: []\n      };\n    }\n\n    for (var resourceId in resourceStore) {\n      var resource = resourceStore[resourceId];\n\n      if (resource.parentId) {\n        var parentNode = nodeHash[resource.parentId];\n\n        if (parentNode) {\n          insertResourceNodeInSiblings(nodeHash[resourceId], parentNode.children, orderSpecs);\n        }\n      }\n    }\n\n    return nodeHash;\n  }\n\n  function insertResourceNode(resourceNode, nodes, groupSpecs, depth, maxDepth, orderSpecs) {\n    if (groupSpecs.length && (maxDepth === -1 || depth <= maxDepth)) {\n      var groupNode = ensureGroupNodes(resourceNode, nodes, groupSpecs[0]);\n      insertResourceNode(resourceNode, groupNode.children, groupSpecs.slice(1), depth + 1, maxDepth, orderSpecs);\n    } else {\n      insertResourceNodeInSiblings(resourceNode, nodes, orderSpecs);\n    }\n  }\n\n  function ensureGroupNodes(resourceNode, nodes, groupSpec) {\n    var groupValue = resourceNode.resourceFields[groupSpec.field];\n    var groupNode;\n    var newGroupIndex; // find an existing group that matches, or determine the position for a new group\n\n    if (groupSpec.order) {\n      for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex++) {\n        var node = nodes[newGroupIndex];\n\n        if (node.group) {\n          var cmp = core.flexibleCompare(groupValue, node.group.value) * groupSpec.order;\n\n          if (cmp === 0) {\n            groupNode = node;\n            break;\n          } else if (cmp < 0) {\n            break;\n          }\n        }\n      }\n    } else {\n      // the groups are unordered\n      for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex++) {\n        var node = nodes[newGroupIndex];\n\n        if (node.group && groupValue === node.group.value) {\n          groupNode = node;\n          break;\n        }\n      }\n    }\n\n    if (!groupNode) {\n      groupNode = {\n        group: {\n          value: groupValue,\n          spec: groupSpec\n        },\n        children: []\n      };\n      nodes.splice(newGroupIndex, 0, groupNode);\n    }\n\n    return groupNode;\n  }\n\n  function insertResourceNodeInSiblings(resourceNode, siblings, orderSpecs) {\n    var i;\n\n    for (i = 0; i < siblings.length; i++) {\n      var cmp = core.compareByFieldSpecs(siblings[i].resourceFields, resourceNode.resourceFields, orderSpecs);\n\n      if (cmp > 0) {\n        // went 1 past. insert at i\n        break;\n      }\n    }\n\n    siblings.splice(i, 0, resourceNode);\n  }\n\n  function buildResourceFields(resource) {\n    var obj = __assign({}, resource.extendedProps, resource.ui, resource);\n\n    delete obj.ui;\n    delete obj.extendedProps;\n    return obj;\n  }\n\n  function isGroupsEqual(group0, group1) {\n    return group0.spec === group1.spec && group0.value === group1.value;\n  }\n\n  var main = core.createPlugin({\n    reducers: [resourcesReducers],\n    eventDefParsers: [parseEventDef],\n    eventDragMutationMassagers: [massageEventDragMutation],\n    eventDefMutationAppliers: [applyEventDefMutation],\n    dateSelectionTransformers: [transformDateSelectionJoin],\n    datePointTransforms: [transformDatePoint],\n    dateSpanTransforms: [transformDateSpan],\n    viewPropsTransformers: [ResourceDataAdder, ResourceEventConfigAdder],\n    isPropsValid: isPropsValidWithResources,\n    externalDefTransforms: [transformExternalDef],\n    eventResizeJoinTransforms: [transformEventResizeJoin],\n    viewContainerModifiers: [injectLicenseWarning],\n    eventDropTransformers: [transformEventDrop],\n    optionChangeHandlers: optionChangeHandlers\n  });\n  exports.AbstractResourceDayTable = AbstractResourceDayTable;\n  exports.DayResourceTable = DayResourceTable;\n  exports.ResourceApi = ResourceApi;\n  exports.ResourceDayHeader = ResourceDayHeader;\n  exports.ResourceDayTable = ResourceDayTable;\n  exports.ResourceSplitter = ResourceSplitter;\n  exports.VResourceJoiner = VResourceJoiner;\n  exports.VResourceSplitter = VResourceSplitter;\n  exports.buildResourceFields = buildResourceFields;\n  exports.buildResourceTextFunc = buildResourceTextFunc;\n  exports.buildRowNodes = buildRowNodes;\n  exports.computeResourceEditable = computeResourceEditable;\n  exports.default = main;\n  exports.flattenResources = flattenResources;\n  exports.isGroupsEqual = isGroupsEqual;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}