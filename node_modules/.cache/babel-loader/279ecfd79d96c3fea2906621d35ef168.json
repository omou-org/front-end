{"ast":null,"code":"/*!\nFullCalendar Timeline Plugin v4.2.0\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2019 Adam Shaw\n*/\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@fullcalendar/core')) : typeof define === 'function' && define.amd ? define(['exports', '@fullcalendar/core'], factory) : (global = global || self, factory(global.FullCalendarTimeline = {}, global.FullCalendar));\n})(this, function (exports, core) {\n  'use strict';\n  /*! *****************************************************************************\r\n  Copyright (c) Microsoft Corporation. All rights reserved.\r\n  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n  this file except in compliance with the License. You may obtain a copy of the\r\n  License at http://www.apache.org/licenses/LICENSE-2.0\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n  MERCHANTABLITY OR NON-INFRINGEMENT.\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n  and limitations under the License.\r\n  ***************************************************************************** */\n\n  /* global Reflect, Promise */\n\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  function __extends(d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  }\n\n  var __assign = function () {\n    __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n\n      return t;\n    };\n\n    return __assign.apply(this, arguments);\n  };\n  /*\n  A rectangular area of content that lives within a Scroller.\n  Can have \"gutters\", areas of dead spacing around the perimeter.\n  Also very useful for forcing a width, which a Scroller cannot do alone.\n  Has a content area that lives above a background area.\n  */\n\n\n  var ScrollerCanvas =\n  /** @class */\n  function () {\n    function ScrollerCanvas() {\n      this.gutters = {};\n      this.el = core.htmlToElement(\"<div class=\\\"fc-scroller-canvas\\\"> <div class=\\\"fc-content\\\"></div> <div class=\\\"fc-bg\\\"></div> </div>\");\n      this.contentEl = this.el.querySelector('.fc-content');\n      this.bgEl = this.el.querySelector('.fc-bg');\n    }\n    /*\n    If falsy, resets all the gutters to 0\n    */\n\n\n    ScrollerCanvas.prototype.setGutters = function (gutters) {\n      if (!gutters) {\n        this.gutters = {};\n      } else {\n        __assign(this.gutters, gutters);\n      }\n\n      this.updateSize();\n    };\n\n    ScrollerCanvas.prototype.setWidth = function (width) {\n      this.width = width;\n      this.updateSize();\n    };\n\n    ScrollerCanvas.prototype.setMinWidth = function (minWidth) {\n      this.minWidth = minWidth;\n      this.updateSize();\n    };\n\n    ScrollerCanvas.prototype.clearWidth = function () {\n      this.width = null;\n      this.minWidth = null;\n      this.updateSize();\n    };\n\n    ScrollerCanvas.prototype.updateSize = function () {\n      var _a = this,\n          gutters = _a.gutters,\n          el = _a.el; // is border-box (width includes padding)\n\n\n      core.forceClassName(el, 'fc-gutter-left', gutters.left);\n      core.forceClassName(el, 'fc-gutter-right', gutters.right);\n      core.forceClassName(el, 'fc-gutter-top', gutters.top);\n      core.forceClassName(el, 'fc-gutter-bottom', gutters.bottom);\n      core.applyStyle(el, {\n        paddingLeft: gutters.left || '',\n        paddingRight: gutters.right || '',\n        paddingTop: gutters.top || '',\n        paddingBottom: gutters.bottom || '',\n        width: this.width != null ? this.width + (gutters.left || 0) + (gutters.right || 0) : '',\n        minWidth: this.minWidth != null ? this.minWidth + (gutters.left || 0) + (gutters.right || 0) : ''\n      });\n      core.applyStyle(this.bgEl, {\n        left: gutters.left || '',\n        right: gutters.right || '',\n        top: gutters.top || '',\n        bottom: gutters.bottom || ''\n      });\n    };\n\n    return ScrollerCanvas;\n  }();\n\n  var EnhancedScroller =\n  /** @class */\n  function (_super) {\n    __extends(EnhancedScroller, _super);\n\n    function EnhancedScroller(overflowX, overflowY) {\n      var _this = _super.call(this, overflowX, overflowY) || this; // Scroll Events\n      // ----------------------------------------------------------------------------------------------\n\n\n      _this.reportScroll = function () {\n        if (!_this.isScrolling) {\n          _this.reportScrollStart();\n        }\n\n        _this.trigger('scroll');\n\n        _this.isMoving = true;\n\n        _this.requestMovingEnd();\n      };\n\n      _this.reportScrollStart = function () {\n        if (!_this.isScrolling) {\n          _this.isScrolling = true;\n\n          _this.trigger('scrollStart', _this.isTouching); // created in constructor\n\n        }\n      }; // Touch Events\n      // ----------------------------------------------------------------------------------------------\n      // will fire *before* the scroll event is fired\n\n\n      _this.reportTouchStart = function () {\n        _this.isTouching = true;\n      };\n\n      _this.reportTouchEnd = function () {\n        if (_this.isTouching) {\n          _this.isTouching = false; // if touch scrolling was re-enabled during a recent touch scroll\n          // then unbind the handlers that are preventing it from happening.\n\n          if (_this.isTouchScrollEnabled) {\n            _this.unbindPreventTouchScroll(); // won't do anything if not bound\n\n          } // if the user ended their touch, and the scroll area wasn't moving,\n          // we consider this to be the end of the scroll.\n\n\n          if (!_this.isMoving) {\n            _this.reportScrollEnd(); // won't fire if already ended\n\n          }\n        }\n      };\n\n      _this.isScrolling = false;\n      _this.isTouching = false;\n      _this.isMoving = false;\n      _this.isTouchScrollEnabled = true;\n      _this.requestMovingEnd = core.debounce(_this.reportMovingEnd, 500);\n      _this.canvas = new ScrollerCanvas();\n\n      _this.el.appendChild(_this.canvas.el);\n\n      _this.applyOverflow();\n\n      _this.bindHandlers();\n\n      return _this;\n    }\n\n    EnhancedScroller.prototype.destroy = function () {\n      _super.prototype.destroy.call(this);\n\n      this.unbindHandlers();\n    }; // Touch scroll prevention\n    // ----------------------------------------------------------------------------------------------\n\n\n    EnhancedScroller.prototype.disableTouchScroll = function () {\n      this.isTouchScrollEnabled = false;\n      this.bindPreventTouchScroll(); // will be unbound in enableTouchScroll or reportTouchEnd\n    };\n\n    EnhancedScroller.prototype.enableTouchScroll = function () {\n      this.isTouchScrollEnabled = true; // only immediately unbind if a touch event is NOT in progress.\n      // otherwise, it will be handled by reportTouchEnd.\n\n      if (!this.isTouching) {\n        this.unbindPreventTouchScroll();\n      }\n    };\n\n    EnhancedScroller.prototype.bindPreventTouchScroll = function () {\n      if (!this.preventTouchScrollHandler) {\n        this.el.addEventListener('touchmove', this.preventTouchScrollHandler = core.preventDefault);\n      }\n    };\n\n    EnhancedScroller.prototype.unbindPreventTouchScroll = function () {\n      if (this.preventTouchScrollHandler) {\n        this.el.removeEventListener('touchmove', this.preventTouchScrollHandler);\n        this.preventTouchScrollHandler = null;\n      }\n    }; // Handlers\n    // ----------------------------------------------------------------------------------------------\n\n\n    EnhancedScroller.prototype.bindHandlers = function () {\n      this.el.addEventListener('scroll', this.reportScroll);\n      this.el.addEventListener('touchstart', this.reportTouchStart, {\n        passive: true\n      });\n      this.el.addEventListener('touchend', this.reportTouchEnd);\n    };\n\n    EnhancedScroller.prototype.unbindHandlers = function () {\n      this.el.removeEventListener('scroll', this.reportScroll);\n      this.el.removeEventListener('touchstart', this.reportTouchStart, {\n        passive: true\n      });\n      this.el.removeEventListener('touchend', this.reportTouchEnd);\n    };\n\n    EnhancedScroller.prototype.reportMovingEnd = function () {\n      this.isMoving = false; // only end the scroll if not currently touching.\n      // if touching, the scrolling will end later, on touchend.\n\n      if (!this.isTouching) {\n        this.reportScrollEnd();\n      }\n    };\n\n    EnhancedScroller.prototype.reportScrollEnd = function () {\n      if (this.isScrolling) {\n        this.trigger('scrollEnd');\n        this.isScrolling = false;\n      }\n    }; // Horizontal Scroll Normalization\n    // ----------------------------------------------------------------------------------------------\n    // http://stackoverflow.com/questions/24276619/better-way-to-get-the-viewport-of-a-scrollable-div-in-rtl-mode/24394376#24394376\n    // TODO: move all this to util functions\n\n    /*\n    If RTL, and scrolled to the left, returns NEGATIVE value (like Firefox)\n    */\n\n\n    EnhancedScroller.prototype.getScrollLeft = function () {\n      var el = this.el;\n      var direction = window.getComputedStyle(el).direction;\n      var val = el.scrollLeft;\n\n      if (direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n          case 'positive':\n            val = val + el.clientWidth - el.scrollWidth;\n            break;\n\n          case 'reverse':\n            val = -val;\n            break;\n        }\n      }\n\n      return val;\n    };\n    /*\n    Accepts a NEGATIVE value for when scrolled in RTL\n    */\n\n\n    EnhancedScroller.prototype.setScrollLeft = function (val) {\n      var el = this.el;\n      var direction = window.getComputedStyle(el).direction;\n\n      if (direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n          case 'positive':\n            val = val - el.clientWidth + el.scrollWidth;\n            break;\n\n          case 'reverse':\n            val = -val;\n            break;\n        }\n      }\n\n      el.scrollLeft = val;\n    };\n    /*\n    Always returns the number of pixels scrolled from the leftmost position (even if RTL).\n    Always positive.\n    */\n\n\n    EnhancedScroller.prototype.getScrollFromLeft = function () {\n      var el = this.el;\n      var direction = window.getComputedStyle(el).direction;\n      var val = el.scrollLeft;\n\n      if (direction === 'rtl') {\n        switch (getRtlScrollSystem()) {\n          case 'negative':\n            val = val - el.clientWidth + el.scrollWidth;\n            break;\n\n          case 'reverse':\n            val = -val - el.clientWidth + el.scrollWidth;\n            break;\n        }\n      }\n\n      return val;\n    };\n\n    return EnhancedScroller;\n  }(core.ScrollComponent);\n\n  core.EmitterMixin.mixInto(EnhancedScroller); // Horizontal Scroll System Detection\n  // ----------------------------------------------------------------------------------------------\n\n  var _rtlScrollSystem;\n\n  function getRtlScrollSystem() {\n    return _rtlScrollSystem || (_rtlScrollSystem = detectRtlScrollSystem());\n  }\n\n  function detectRtlScrollSystem() {\n    var el = core.htmlToElement(\"<div style=\\\" position: absolute; top: -1000px; width: 1px; height: 1px; overflow: scroll; direction: rtl; font-size: 100px; \\\">A</div>\");\n    document.body.appendChild(el);\n    var system;\n\n    if (el.scrollLeft > 0) {\n      system = 'positive';\n    } else {\n      el.scrollLeft = 1;\n\n      if (el.scrollLeft > 0) {\n        system = 'reverse';\n      } else {\n        system = 'negative';\n      }\n    }\n\n    core.removeElement(el);\n    return system;\n  }\n  /*\n  A Scroller, but with a wrapping div that allows \"clipping\" away of native scrollbars,\n  giving the appearance that there are no scrollbars.\n  */\n\n\n  var ClippedScroller =\n  /** @class */\n  function () {\n    /*\n    Received overflows can be set to 'clipped', meaning scrollbars shouldn't be visible\n    to the user, but the area should still scroll.\n    */\n    function ClippedScroller(overflowX, overflowY, parentEl) {\n      this.isHScrollbarsClipped = false;\n      this.isVScrollbarsClipped = false;\n\n      if (overflowX === 'clipped-scroll') {\n        overflowX = 'scroll';\n        this.isHScrollbarsClipped = true;\n      }\n\n      if (overflowY === 'clipped-scroll') {\n        overflowY = 'scroll';\n        this.isVScrollbarsClipped = true;\n      }\n\n      this.enhancedScroll = new EnhancedScroller(overflowX, overflowY);\n      parentEl.appendChild(this.el = core.createElement('div', {\n        className: 'fc-scroller-clip'\n      }));\n      this.el.appendChild(this.enhancedScroll.el);\n    }\n\n    ClippedScroller.prototype.destroy = function () {\n      core.removeElement(this.el);\n    };\n\n    ClippedScroller.prototype.updateSize = function () {\n      var enhancedScroll = this.enhancedScroll;\n      var scrollEl = enhancedScroll.el;\n      var edges = core.computeEdges(scrollEl);\n      var cssProps = {\n        marginLeft: 0,\n        marginRight: 0,\n        marginTop: 0,\n        marginBottom: 0\n      }; // give the inner scrolling div negative margins so that its scrollbars\n      // are nudged outside of the bounding box of the wrapper, which is overflow:hidden\n\n      if (this.isVScrollbarsClipped) {\n        cssProps.marginLeft = -edges.scrollbarLeft;\n        cssProps.marginRight = -edges.scrollbarRight;\n      }\n\n      if (this.isHScrollbarsClipped) {\n        cssProps.marginBottom = -edges.scrollbarBottom;\n      }\n\n      core.applyStyle(scrollEl, cssProps); // if we are attempting to hide the scrollbars offscreen, OSX/iOS will still\n      // display the floating scrollbars. attach a className to force-hide them.\n\n      if ((this.isHScrollbarsClipped || enhancedScroll.overflowX === 'hidden') && ( // should never show?\n      this.isVScrollbarsClipped || enhancedScroll.overflowY === 'hidden') && // should never show?\n      !( // doesn't have any scrollbar mass\n      edges.scrollbarLeft || edges.scrollbarRight || edges.scrollbarBottom)) {\n        scrollEl.classList.add('fc-no-scrollbars');\n      } else {\n        scrollEl.classList.remove('fc-no-scrollbars');\n      }\n    };\n\n    ClippedScroller.prototype.setHeight = function (height) {\n      this.enhancedScroll.setHeight(height);\n    };\n    /*\n    Accounts for 'clipped' scrollbars\n    */\n\n\n    ClippedScroller.prototype.getScrollbarWidths = function () {\n      var widths = this.enhancedScroll.getScrollbarWidths();\n\n      if (this.isVScrollbarsClipped) {\n        widths.left = 0;\n        widths.right = 0;\n      }\n\n      if (this.isHScrollbarsClipped) {\n        widths.bottom = 0;\n      }\n\n      return widths;\n    };\n\n    return ClippedScroller;\n  }();\n\n  var ScrollJoiner =\n  /** @class */\n  function () {\n    function ScrollJoiner(axis, scrollers) {\n      this.axis = axis;\n      this.scrollers = scrollers;\n\n      for (var _i = 0, _a = this.scrollers; _i < _a.length; _i++) {\n        var scroller = _a[_i];\n        this.initScroller(scroller);\n      }\n    }\n\n    ScrollJoiner.prototype.initScroller = function (scroller) {\n      var _this = this;\n\n      var enhancedScroll = scroller.enhancedScroll; // when the user scrolls via mousewheel, we know for sure the target\n      // scroller should be the master. capture the various x-browser events that fire.\n\n      var onScroll = function () {\n        _this.assignMasterScroller(scroller);\n      };\n\n      'wheel mousewheel DomMouseScroll MozMousePixelScroll'.split(' ').forEach(function (evName) {\n        enhancedScroll.el.addEventListener(evName, onScroll);\n      });\n      enhancedScroll.on('scrollStart', function () {\n        if (!_this.masterScroller) {\n          _this.assignMasterScroller(scroller);\n        }\n      }).on('scroll', function () {\n        if (scroller === _this.masterScroller) {\n          for (var _i = 0, _a = _this.scrollers; _i < _a.length; _i++) {\n            var otherScroller = _a[_i];\n\n            if (otherScroller !== scroller) {\n              switch (_this.axis) {\n                case 'horizontal':\n                  otherScroller.enhancedScroll.el.scrollLeft = enhancedScroll.el.scrollLeft;\n                  break;\n\n                case 'vertical':\n                  otherScroller.enhancedScroll.setScrollTop(enhancedScroll.getScrollTop());\n                  break;\n              }\n            }\n          }\n        }\n      }).on('scrollEnd', function () {\n        if (scroller === _this.masterScroller) {\n          _this.unassignMasterScroller();\n        }\n      });\n    };\n\n    ScrollJoiner.prototype.assignMasterScroller = function (scroller) {\n      this.unassignMasterScroller();\n      this.masterScroller = scroller;\n\n      for (var _i = 0, _a = this.scrollers; _i < _a.length; _i++) {\n        var otherScroller = _a[_i];\n\n        if (otherScroller !== scroller) {\n          otherScroller.enhancedScroll.disableTouchScroll();\n        }\n      }\n    };\n\n    ScrollJoiner.prototype.unassignMasterScroller = function () {\n      if (this.masterScroller) {\n        for (var _i = 0, _a = this.scrollers; _i < _a.length; _i++) {\n          var otherScroller = _a[_i];\n          otherScroller.enhancedScroll.enableTouchScroll();\n        }\n\n        this.masterScroller = null;\n      }\n    };\n\n    ScrollJoiner.prototype.update = function () {\n      var allWidths = this.scrollers.map(function (scroller) {\n        return scroller.getScrollbarWidths();\n      });\n      var maxLeft = 0;\n      var maxRight = 0;\n      var maxTop = 0;\n      var maxBottom = 0;\n      var widths;\n      var i;\n\n      for (var _i = 0, allWidths_1 = allWidths; _i < allWidths_1.length; _i++) {\n        widths = allWidths_1[_i];\n        maxLeft = Math.max(maxLeft, widths.left);\n        maxRight = Math.max(maxRight, widths.right);\n        maxTop = Math.max(maxTop, widths.top);\n        maxBottom = Math.max(maxBottom, widths.bottom);\n      }\n\n      for (i = 0; i < this.scrollers.length; i++) {\n        var scroller = this.scrollers[i];\n        widths = allWidths[i];\n        scroller.enhancedScroll.canvas.setGutters(this.axis === 'horizontal' ? {\n          left: maxLeft - widths.left,\n          right: maxRight - widths.right\n        } : {\n          top: maxTop - widths.top,\n          bottom: maxBottom - widths.bottom\n        });\n      }\n    };\n\n    return ScrollJoiner;\n  }();\n\n  var HeaderBodyLayout =\n  /** @class */\n  function () {\n    /*\n    verticalScroll = 'auto' | 'clipped-scroll'\n    */\n    function HeaderBodyLayout(headerContainerEl, bodyContainerEl, verticalScroll) {\n      this.headerScroller = new ClippedScroller('clipped-scroll', 'hidden', headerContainerEl);\n      this.bodyScroller = new ClippedScroller('auto', verticalScroll, bodyContainerEl);\n      this.scrollJoiner = new ScrollJoiner('horizontal', [this.headerScroller, this.bodyScroller]);\n    }\n\n    HeaderBodyLayout.prototype.destroy = function () {\n      this.headerScroller.destroy();\n      this.bodyScroller.destroy();\n    };\n\n    HeaderBodyLayout.prototype.setHeight = function (totalHeight, isAuto) {\n      var bodyHeight;\n\n      if (isAuto) {\n        bodyHeight = 'auto';\n      } else {\n        bodyHeight = totalHeight - this.queryHeadHeight();\n      }\n\n      this.bodyScroller.setHeight(bodyHeight);\n      this.headerScroller.updateSize(); // adjusts gutters and classNames\n\n      this.bodyScroller.updateSize(); // adjusts gutters and classNames\n\n      this.scrollJoiner.update();\n    };\n\n    HeaderBodyLayout.prototype.queryHeadHeight = function () {\n      return this.headerScroller.enhancedScroll.canvas.contentEl.offsetHeight; // flawed?\n    };\n\n    return HeaderBodyLayout;\n  }();\n\n  var TimelineHeader =\n  /** @class */\n  function (_super) {\n    __extends(TimelineHeader, _super);\n\n    function TimelineHeader(context, parentEl) {\n      var _this = _super.call(this, context) || this;\n\n      parentEl.appendChild(_this.tableEl = core.createElement('table', {\n        className: _this.theme.getClass('tableGrid')\n      }));\n      return _this;\n    }\n\n    TimelineHeader.prototype.destroy = function () {\n      core.removeElement(this.tableEl);\n\n      _super.prototype.destroy.call(this);\n    };\n\n    TimelineHeader.prototype.render = function (props) {\n      this.renderDates(props.tDateProfile);\n    };\n\n    TimelineHeader.prototype.renderDates = function (tDateProfile) {\n      var _a = this,\n          dateEnv = _a.dateEnv,\n          theme = _a.theme;\n\n      var cellRows = tDateProfile.cellRows;\n      var lastRow = cellRows[cellRows.length - 1];\n      var isChrono = core.asRoughMs(tDateProfile.labelInterval) > core.asRoughMs(tDateProfile.slotDuration);\n      var oneDay = core.isSingleDay(tDateProfile.slotDuration);\n      var html = '<colgroup>'; // needs to be a col for each body slat. header cells will have colspans\n\n      for (var i = tDateProfile.slotCnt - 1; i >= 0; i--) {\n        html += '<col/>';\n      }\n\n      html += '</colgroup>';\n      html += '<tbody>';\n\n      for (var _i = 0, cellRows_1 = cellRows; _i < cellRows_1.length; _i++) {\n        var rowCells = cellRows_1[_i];\n        var isLast = rowCells === lastRow;\n        html += '<tr' + (isChrono && isLast ? ' class=\"fc-chrono\"' : '') + '>';\n\n        for (var _b = 0, rowCells_1 = rowCells; _b < rowCells_1.length; _b++) {\n          var cell = rowCells_1[_b];\n          var headerCellClassNames = [theme.getClass('widgetHeader')];\n\n          if (cell.isWeekStart) {\n            headerCellClassNames.push('fc-em-cell');\n          }\n\n          if (oneDay) {\n            headerCellClassNames = headerCellClassNames.concat(core.getDayClasses(cell.date, this.props.dateProfile, this.context, true) // adds \"today\" class and other day-based classes\n            );\n          }\n\n          html += '<th class=\"' + headerCellClassNames.join(' ') + '\"' + ' data-date=\"' + dateEnv.formatIso(cell.date, {\n            omitTime: !tDateProfile.isTimeScale,\n            omitTimeZoneOffset: true\n          }) + '\"' + (cell.colspan > 1 ? ' colspan=\"' + cell.colspan + '\"' : '') + '>' + '<div class=\"fc-cell-content\">' + cell.spanHtml + '</div>' + '</th>';\n        }\n\n        html += '</tr>';\n      }\n\n      html += '</tbody>';\n      this.tableEl.innerHTML = html; // TODO: does this work cross-browser?\n\n      this.slatColEls = core.findElements(this.tableEl, 'col');\n      this.innerEls = core.findElements(this.tableEl.querySelector('tr:last-child'), // compound selector won't work because of query-root problem\n      'th .fc-cell-text');\n      core.findElements(this.tableEl.querySelectorAll('tr:not(:last-child)'), // compound selector won't work because of query-root problem\n      'th .fc-cell-text').forEach(function (innerEl) {\n        innerEl.classList.add('fc-sticky');\n      });\n    };\n\n    return TimelineHeader;\n  }(core.Component);\n\n  var TimelineSlats =\n  /** @class */\n  function (_super) {\n    __extends(TimelineSlats, _super);\n\n    function TimelineSlats(context, parentEl) {\n      var _this = _super.call(this, context) || this;\n\n      parentEl.appendChild(_this.el = core.createElement('div', {\n        className: 'fc-slats'\n      }));\n      return _this;\n    }\n\n    TimelineSlats.prototype.destroy = function () {\n      core.removeElement(this.el);\n\n      _super.prototype.destroy.call(this);\n    };\n\n    TimelineSlats.prototype.render = function (props) {\n      this.renderDates(props.tDateProfile);\n    };\n\n    TimelineSlats.prototype.renderDates = function (tDateProfile) {\n      var _a = this,\n          theme = _a.theme,\n          view = _a.view,\n          dateEnv = _a.dateEnv;\n\n      var slotDates = tDateProfile.slotDates,\n          isWeekStarts = tDateProfile.isWeekStarts;\n      var html = '<table class=\"' + theme.getClass('tableGrid') + '\">' + '<colgroup>';\n\n      for (var i = 0; i < slotDates.length; i++) {\n        html += '<col/>';\n      }\n\n      html += '</colgroup>';\n      html += '<tbody><tr>';\n\n      for (var i = 0; i < slotDates.length; i++) {\n        html += this.slatCellHtml(slotDates[i], isWeekStarts[i], tDateProfile);\n      }\n\n      html += '</tr></tbody></table>';\n      this.el.innerHTML = html;\n      this.slatColEls = core.findElements(this.el, 'col');\n      this.slatEls = core.findElements(this.el, 'td');\n\n      for (var i = 0; i < slotDates.length; i++) {\n        view.publiclyTrigger('dayRender', [{\n          date: dateEnv.toDate(slotDates[i]),\n          el: this.slatEls[i],\n          view: view\n        }]);\n      }\n\n      this.outerCoordCache = new core.PositionCache(this.el, this.slatEls, true, // isHorizontal\n      false // isVertical\n      ); // for the inner divs within the slats\n      // used for event rendering and scrollTime, to disregard slat border\n\n      this.innerCoordCache = new core.PositionCache(this.el, core.findChildren(this.slatEls, 'div'), true, // isHorizontal\n      false // isVertical\n      );\n    };\n\n    TimelineSlats.prototype.slatCellHtml = function (date, isEm, tDateProfile) {\n      var _a = this,\n          theme = _a.theme,\n          dateEnv = _a.dateEnv;\n\n      var classes;\n\n      if (tDateProfile.isTimeScale) {\n        classes = [];\n        classes.push(core.isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval)) ? 'fc-major' : 'fc-minor');\n      } else {\n        classes = core.getDayClasses(date, this.props.dateProfile, this.context);\n        classes.push('fc-day');\n      }\n\n      classes.unshift(theme.getClass('widgetContent'));\n\n      if (isEm) {\n        classes.push('fc-em-cell');\n      }\n\n      return '<td class=\"' + classes.join(' ') + '\"' + ' data-date=\"' + dateEnv.formatIso(date, {\n        omitTime: !tDateProfile.isTimeScale,\n        omitTimeZoneOffset: true\n      }) + '\"' + '><div></div></td>';\n    };\n\n    TimelineSlats.prototype.updateSize = function () {\n      this.outerCoordCache.build();\n      this.innerCoordCache.build();\n    };\n\n    TimelineSlats.prototype.positionToHit = function (leftPosition) {\n      var outerCoordCache = this.outerCoordCache;\n      var tDateProfile = this.props.tDateProfile;\n      var slatIndex = outerCoordCache.leftToIndex(leftPosition);\n\n      if (slatIndex != null) {\n        // somewhat similar to what TimeGrid does. consolidate?\n        var slatWidth = outerCoordCache.getWidth(slatIndex);\n        var partial = this.isRtl ? (outerCoordCache.rights[slatIndex] - leftPosition) / slatWidth : (leftPosition - outerCoordCache.lefts[slatIndex]) / slatWidth;\n        var localSnapIndex = Math.floor(partial * tDateProfile.snapsPerSlot);\n        var start = this.dateEnv.add(tDateProfile.slotDates[slatIndex], core.multiplyDuration(tDateProfile.snapDuration, localSnapIndex));\n        var end = this.dateEnv.add(start, tDateProfile.snapDuration);\n        return {\n          dateSpan: {\n            range: {\n              start: start,\n              end: end\n            },\n            allDay: !this.props.tDateProfile.isTimeScale\n          },\n          dayEl: this.slatColEls[slatIndex],\n          left: outerCoordCache.lefts[slatIndex],\n          right: outerCoordCache.rights[slatIndex]\n        };\n      }\n\n      return null;\n    };\n\n    return TimelineSlats;\n  }(core.Component);\n\n  var MIN_AUTO_LABELS = 18; // more than `12` months but less that `24` hours\n\n  var MAX_AUTO_SLOTS_PER_LABEL = 6; // allows 6 10-min slots in an hour\n\n  var MAX_AUTO_CELLS = 200; // allows 4-days to have a :30 slot duration\n\n  core.config.MAX_TIMELINE_SLOTS = 1000; // potential nice values for slot-duration and interval-duration\n\n  var STOCK_SUB_DURATIONS = [{\n    years: 1\n  }, {\n    months: 1\n  }, {\n    days: 1\n  }, {\n    hours: 1\n  }, {\n    minutes: 30\n  }, {\n    minutes: 15\n  }, {\n    minutes: 10\n  }, {\n    minutes: 5\n  }, {\n    minutes: 1\n  }, {\n    seconds: 30\n  }, {\n    seconds: 15\n  }, {\n    seconds: 10\n  }, {\n    seconds: 5\n  }, {\n    seconds: 1\n  }, {\n    milliseconds: 500\n  }, {\n    milliseconds: 100\n  }, {\n    milliseconds: 10\n  }, {\n    milliseconds: 1\n  }];\n\n  function buildTimelineDateProfile(dateProfile, view) {\n    var dateEnv = view.dateEnv;\n    var tDateProfile = {\n      labelInterval: queryDurationOption(view, 'slotLabelInterval'),\n      slotDuration: queryDurationOption(view, 'slotDuration')\n    };\n    validateLabelAndSlot(tDateProfile, dateProfile, dateEnv); // validate after computed grid duration\n\n    ensureLabelInterval(tDateProfile, dateProfile, dateEnv);\n    ensureSlotDuration(tDateProfile, dateProfile, dateEnv);\n    var input = view.opt('slotLabelFormat');\n    var rawFormats = Array.isArray(input) ? input : input != null ? [input] : computeHeaderFormats(tDateProfile, dateProfile, dateEnv, view);\n    tDateProfile.headerFormats = rawFormats.map(function (rawFormat) {\n      return core.createFormatter(rawFormat);\n    });\n    tDateProfile.isTimeScale = Boolean(tDateProfile.slotDuration.milliseconds);\n    var largeUnit = null;\n\n    if (!tDateProfile.isTimeScale) {\n      var slotUnit = core.greatestDurationDenominator(tDateProfile.slotDuration).unit;\n\n      if (/year|month|week/.test(slotUnit)) {\n        largeUnit = slotUnit;\n      }\n    }\n\n    tDateProfile.largeUnit = largeUnit;\n    tDateProfile.emphasizeWeeks = core.isSingleDay(tDateProfile.slotDuration) && currentRangeAs('weeks', dateProfile, dateEnv) >= 2 && !view.opt('businessHours');\n    /*\n    console.log('label interval =', timelineView.labelInterval.humanize())\n    console.log('slot duration =', timelineView.slotDuration.humanize())\n    console.log('header formats =', timelineView.headerFormats)\n    console.log('isTimeScale', timelineView.isTimeScale)\n    console.log('largeUnit', timelineView.largeUnit)\n    */\n\n    var rawSnapDuration = view.opt('snapDuration');\n    var snapDuration;\n    var snapsPerSlot;\n\n    if (rawSnapDuration) {\n      snapDuration = core.createDuration(rawSnapDuration);\n      snapsPerSlot = core.wholeDivideDurations(tDateProfile.slotDuration, snapDuration); // ^ TODO: warning if not whole?\n    }\n\n    if (snapsPerSlot == null) {\n      snapDuration = tDateProfile.slotDuration;\n      snapsPerSlot = 1;\n    }\n\n    tDateProfile.snapDuration = snapDuration;\n    tDateProfile.snapsPerSlot = snapsPerSlot; // more...\n\n    var timeWindowMs = core.asRoughMs(dateProfile.maxTime) - core.asRoughMs(dateProfile.minTime); // TODO: why not use normalizeRange!?\n\n    var normalizedStart = normalizeDate(dateProfile.renderRange.start, tDateProfile, dateEnv);\n    var normalizedEnd = normalizeDate(dateProfile.renderRange.end, tDateProfile, dateEnv); // apply minTime/maxTime\n    // TODO: View should be responsible.\n\n    if (tDateProfile.isTimeScale) {\n      normalizedStart = dateEnv.add(normalizedStart, dateProfile.minTime);\n      normalizedEnd = dateEnv.add(core.addDays(normalizedEnd, -1), dateProfile.maxTime);\n    }\n\n    tDateProfile.timeWindowMs = timeWindowMs;\n    tDateProfile.normalizedRange = {\n      start: normalizedStart,\n      end: normalizedEnd\n    };\n    var slotDates = [];\n    var date = normalizedStart;\n\n    while (date < normalizedEnd) {\n      if (isValidDate(date, tDateProfile, dateProfile, view)) {\n        slotDates.push(date);\n      }\n\n      date = dateEnv.add(date, tDateProfile.slotDuration);\n    }\n\n    tDateProfile.slotDates = slotDates; // more...\n\n    var snapIndex = -1;\n    var snapDiff = 0; // index of the diff :(\n\n    var snapDiffToIndex = [];\n    var snapIndexToDiff = [];\n    date = normalizedStart;\n\n    while (date < normalizedEnd) {\n      if (isValidDate(date, tDateProfile, dateProfile, view)) {\n        snapIndex++;\n        snapDiffToIndex.push(snapIndex);\n        snapIndexToDiff.push(snapDiff);\n      } else {\n        snapDiffToIndex.push(snapIndex + 0.5);\n      }\n\n      date = dateEnv.add(date, tDateProfile.snapDuration);\n      snapDiff++;\n    }\n\n    tDateProfile.snapDiffToIndex = snapDiffToIndex;\n    tDateProfile.snapIndexToDiff = snapIndexToDiff;\n    tDateProfile.snapCnt = snapIndex + 1; // is always one behind\n\n    tDateProfile.slotCnt = tDateProfile.snapCnt / tDateProfile.snapsPerSlot; // more...\n\n    tDateProfile.isWeekStarts = buildIsWeekStarts(tDateProfile, dateEnv);\n    tDateProfile.cellRows = buildCellRows(tDateProfile, dateEnv, view);\n    return tDateProfile;\n  }\n  /*\n  snaps to appropriate unit\n  */\n\n\n  function normalizeDate(date, tDateProfile, dateEnv) {\n    var normalDate = date;\n\n    if (!tDateProfile.isTimeScale) {\n      normalDate = core.startOfDay(normalDate);\n\n      if (tDateProfile.largeUnit) {\n        normalDate = dateEnv.startOf(normalDate, tDateProfile.largeUnit);\n      }\n    }\n\n    return normalDate;\n  }\n  /*\n  snaps to appropriate unit\n  */\n\n\n  function normalizeRange(range, tDateProfile, dateEnv) {\n    if (!tDateProfile.isTimeScale) {\n      range = core.computeVisibleDayRange(range);\n\n      if (tDateProfile.largeUnit) {\n        var dayRange = range; // preserve original result\n\n        range = {\n          start: dateEnv.startOf(range.start, tDateProfile.largeUnit),\n          end: dateEnv.startOf(range.end, tDateProfile.largeUnit)\n        }; // if date is partially through the interval, or is in the same interval as the start,\n        // make the exclusive end be the *next* interval\n\n        if (range.end.valueOf() !== dayRange.end.valueOf() || range.end <= range.start) {\n          range = {\n            start: range.start,\n            end: dateEnv.add(range.end, tDateProfile.slotDuration)\n          };\n        }\n      }\n    }\n\n    return range;\n  }\n\n  function isValidDate(date, tDateProfile, dateProfile, view) {\n    if (view.dateProfileGenerator.isHiddenDay(date)) {\n      return false;\n    } else if (tDateProfile.isTimeScale) {\n      // determine if the time is within minTime/maxTime, which may have wacky values\n      var day = core.startOfDay(date);\n      var timeMs = date.valueOf() - day.valueOf();\n      var ms = timeMs - core.asRoughMs(dateProfile.minTime); // milliseconds since minTime\n\n      ms = (ms % 86400000 + 86400000) % 86400000; // make negative values wrap to 24hr clock\n\n      return ms < tDateProfile.timeWindowMs; // before the maxTime?\n    } else {\n      return true;\n    }\n  }\n\n  function queryDurationOption(view, name) {\n    var input = view.opt(name);\n\n    if (input != null) {\n      return core.createDuration(input);\n    }\n  }\n\n  function validateLabelAndSlot(tDateProfile, dateProfile, dateEnv) {\n    var currentRange = dateProfile.currentRange; // make sure labelInterval doesn't exceed the max number of cells\n\n    if (tDateProfile.labelInterval) {\n      var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.labelInterval);\n\n      if (labelCnt > core.config.MAX_TIMELINE_SLOTS) {\n        console.warn('slotLabelInterval results in too many cells');\n        tDateProfile.labelInterval = null;\n      }\n    } // make sure slotDuration doesn't exceed the maximum number of cells\n\n\n    if (tDateProfile.slotDuration) {\n      var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, tDateProfile.slotDuration);\n\n      if (slotCnt > core.config.MAX_TIMELINE_SLOTS) {\n        console.warn('slotDuration results in too many cells');\n        tDateProfile.slotDuration = null;\n      }\n    } // make sure labelInterval is a multiple of slotDuration\n\n\n    if (tDateProfile.labelInterval && tDateProfile.slotDuration) {\n      var slotsPerLabel = core.wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n\n      if (slotsPerLabel === null || slotsPerLabel < 1) {\n        console.warn('slotLabelInterval must be a multiple of slotDuration');\n        tDateProfile.slotDuration = null;\n      }\n    }\n  }\n\n  function ensureLabelInterval(tDateProfile, dateProfile, dateEnv) {\n    var currentRange = dateProfile.currentRange;\n    var labelInterval = tDateProfile.labelInterval;\n\n    if (!labelInterval) {\n      // compute based off the slot duration\n      // find the largest label interval with an acceptable slots-per-label\n      var input = void 0;\n\n      if (tDateProfile.slotDuration) {\n        for (var _i = 0, STOCK_SUB_DURATIONS_1 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_1.length; _i++) {\n          input = STOCK_SUB_DURATIONS_1[_i];\n          var tryLabelInterval = core.createDuration(input);\n          var slotsPerLabel = core.wholeDivideDurations(tryLabelInterval, tDateProfile.slotDuration);\n\n          if (slotsPerLabel !== null && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n            labelInterval = tryLabelInterval;\n            break;\n          }\n        } // use the slot duration as a last resort\n\n\n        if (!labelInterval) {\n          labelInterval = tDateProfile.slotDuration;\n        } // compute based off the view's duration\n        // find the largest label interval that yields the minimum number of labels\n\n      } else {\n        for (var _a = 0, STOCK_SUB_DURATIONS_2 = STOCK_SUB_DURATIONS; _a < STOCK_SUB_DURATIONS_2.length; _a++) {\n          input = STOCK_SUB_DURATIONS_2[_a];\n          labelInterval = core.createDuration(input);\n          var labelCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, labelInterval);\n\n          if (labelCnt >= MIN_AUTO_LABELS) {\n            break;\n          }\n        }\n      }\n\n      tDateProfile.labelInterval = labelInterval;\n    }\n\n    return labelInterval;\n  }\n\n  function ensureSlotDuration(tDateProfile, dateProfile, dateEnv) {\n    var currentRange = dateProfile.currentRange;\n    var slotDuration = tDateProfile.slotDuration;\n\n    if (!slotDuration) {\n      var labelInterval = ensureLabelInterval(tDateProfile, dateProfile, dateEnv); // will compute if necessary\n      // compute based off the label interval\n      // find the largest slot duration that is different from labelInterval, but still acceptable\n\n      for (var _i = 0, STOCK_SUB_DURATIONS_3 = STOCK_SUB_DURATIONS; _i < STOCK_SUB_DURATIONS_3.length; _i++) {\n        var input = STOCK_SUB_DURATIONS_3[_i];\n        var trySlotDuration = core.createDuration(input);\n        var slotsPerLabel = core.wholeDivideDurations(labelInterval, trySlotDuration);\n\n        if (slotsPerLabel !== null && slotsPerLabel > 1 && slotsPerLabel <= MAX_AUTO_SLOTS_PER_LABEL) {\n          slotDuration = trySlotDuration;\n          break;\n        }\n      } // only allow the value if it won't exceed the view's # of slots limit\n\n\n      if (slotDuration) {\n        var slotCnt = dateEnv.countDurationsBetween(currentRange.start, currentRange.end, slotDuration);\n\n        if (slotCnt > MAX_AUTO_CELLS) {\n          slotDuration = null;\n        }\n      } // use the label interval as a last resort\n\n\n      if (!slotDuration) {\n        slotDuration = labelInterval;\n      }\n\n      tDateProfile.slotDuration = slotDuration;\n    }\n\n    return slotDuration;\n  }\n\n  function computeHeaderFormats(tDateProfile, dateProfile, dateEnv, view) {\n    var format1;\n    var format2;\n    var labelInterval = tDateProfile.labelInterval;\n    var unit = core.greatestDurationDenominator(labelInterval).unit;\n    var weekNumbersVisible = view.opt('weekNumbers');\n    var format0 = format1 = format2 = null; // NOTE: weekNumber computation function wont work\n\n    if (unit === 'week' && !weekNumbersVisible) {\n      unit = 'day';\n    }\n\n    switch (unit) {\n      case 'year':\n        format0 = {\n          year: 'numeric'\n        }; // '2015'\n\n        break;\n\n      case 'month':\n        if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n          format0 = {\n            year: 'numeric'\n          }; // '2015'\n        }\n\n        format1 = {\n          month: 'short'\n        }; // 'Jan'\n\n        break;\n\n      case 'week':\n        if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n          format0 = {\n            year: 'numeric'\n          }; // '2015'\n        }\n\n        format1 = {\n          week: 'narrow'\n        }; // 'Wk4'\n\n        break;\n\n      case 'day':\n        if (currentRangeAs('years', dateProfile, dateEnv) > 1) {\n          format0 = {\n            year: 'numeric',\n            month: 'long'\n          }; // 'January 2014'\n        } else if (currentRangeAs('months', dateProfile, dateEnv) > 1) {\n          format0 = {\n            month: 'long'\n          }; // 'January'\n        }\n\n        if (weekNumbersVisible) {\n          format1 = {\n            week: 'short'\n          }; // 'Wk 4'\n        }\n\n        format2 = {\n          weekday: 'narrow',\n          day: 'numeric'\n        }; // 'Su 9'\n\n        break;\n\n      case 'hour':\n        if (weekNumbersVisible) {\n          format0 = {\n            week: 'short'\n          }; // 'Wk 4'\n        }\n\n        if (currentRangeAs('days', dateProfile, dateEnv) > 1) {\n          format1 = {\n            weekday: 'short',\n            day: 'numeric',\n            month: 'numeric',\n            omitCommas: true\n          }; // Sat 4/7\n        }\n\n        format2 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          omitZeroMinute: true,\n          meridiem: 'short'\n        };\n        break;\n\n      case 'minute':\n        // sufficiently large number of different minute cells?\n        if (core.asRoughMinutes(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n          format0 = {\n            hour: 'numeric',\n            meridiem: 'short'\n          };\n\n          format1 = function (params) {\n            return ':' + core.padStart(params.date.minute, 2); // ':30'\n          };\n        } else {\n          format0 = {\n            hour: 'numeric',\n            minute: 'numeric',\n            meridiem: 'short'\n          };\n        }\n\n        break;\n\n      case 'second':\n        // sufficiently large number of different second cells?\n        if (core.asRoughSeconds(labelInterval) / 60 >= MAX_AUTO_SLOTS_PER_LABEL) {\n          format0 = {\n            hour: 'numeric',\n            minute: '2-digit',\n            meridiem: 'lowercase'\n          }; // '8:30 PM'\n\n          format1 = function (params) {\n            return ':' + core.padStart(params.date.second, 2); // ':30'\n          };\n        } else {\n          format0 = {\n            hour: 'numeric',\n            minute: '2-digit',\n            second: '2-digit',\n            meridiem: 'lowercase'\n          }; // '8:30:45 PM'\n        }\n\n        break;\n\n      case 'millisecond':\n        format0 = {\n          hour: 'numeric',\n          minute: '2-digit',\n          second: '2-digit',\n          meridiem: 'lowercase'\n        }; // '8:30:45 PM'\n\n        format1 = function (params) {\n          return '.' + core.padStart(params.millisecond, 3);\n        };\n\n        break;\n    }\n\n    return [].concat(format0 || [], format1 || [], format2 || []);\n  } // Compute the number of the give units in the \"current\" range.\n  // Won't go more precise than days.\n  // Will return `0` if there's not a clean whole interval.\n\n\n  function currentRangeAs(unit, dateProfile, dateEnv) {\n    var range = dateProfile.currentRange;\n    var res = null;\n\n    if (unit === 'years') {\n      res = dateEnv.diffWholeYears(range.start, range.end);\n    } else if (unit === 'months') {\n      res = dateEnv.diffWholeMonths(range.start, range.end);\n    } else if (unit === 'weeks') {\n      res = dateEnv.diffWholeMonths(range.start, range.end);\n    } else if (unit === 'days') {\n      res = core.diffWholeDays(range.start, range.end);\n    }\n\n    return res || 0;\n  }\n\n  function buildIsWeekStarts(tDateProfile, dateEnv) {\n    var slotDates = tDateProfile.slotDates,\n        emphasizeWeeks = tDateProfile.emphasizeWeeks;\n    var prevWeekNumber = null;\n    var isWeekStarts = [];\n\n    for (var _i = 0, slotDates_1 = slotDates; _i < slotDates_1.length; _i++) {\n      var slotDate = slotDates_1[_i];\n      var weekNumber = dateEnv.computeWeekNumber(slotDate);\n      var isWeekStart = emphasizeWeeks && prevWeekNumber !== null && prevWeekNumber !== weekNumber;\n      prevWeekNumber = weekNumber;\n      isWeekStarts.push(isWeekStart);\n    }\n\n    return isWeekStarts;\n  }\n\n  function buildCellRows(tDateProfile, dateEnv, view) {\n    var slotDates = tDateProfile.slotDates;\n    var formats = tDateProfile.headerFormats;\n    var cellRows = formats.map(function (format) {\n      return [];\n    }); // indexed by row,col\n    // specifically for navclicks\n\n    var rowUnits = formats.map(function (format) {\n      return format.getLargestUnit ? format.getLargestUnit() : null;\n    }); // builds cellRows and slotCells\n\n    for (var i = 0; i < slotDates.length; i++) {\n      var date = slotDates[i];\n      var isWeekStart = tDateProfile.isWeekStarts[i];\n\n      for (var row = 0; row < formats.length; row++) {\n        var format = formats[row];\n        var rowCells = cellRows[row];\n        var leadingCell = rowCells[rowCells.length - 1];\n        var isSuperRow = formats.length > 1 && row < formats.length - 1; // more than one row and not the last\n\n        var newCell = null;\n\n        if (isSuperRow) {\n          var text = dateEnv.format(date, format);\n\n          if (!leadingCell || leadingCell.text !== text) {\n            newCell = buildCellObject(date, text, rowUnits[row], view);\n          } else {\n            leadingCell.colspan += 1;\n          }\n        } else {\n          if (!leadingCell || core.isInt(dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.labelInterval))) {\n            var text = dateEnv.format(date, format);\n            newCell = buildCellObject(date, text, rowUnits[row], view);\n          } else {\n            leadingCell.colspan += 1;\n          }\n        }\n\n        if (newCell) {\n          newCell.weekStart = isWeekStart;\n          rowCells.push(newCell);\n        }\n      }\n    }\n\n    return cellRows;\n  }\n\n  function buildCellObject(date, text, rowUnit, view) {\n    var spanHtml = core.buildGotoAnchorHtml(view, {\n      date: date,\n      type: rowUnit,\n      forceOff: !rowUnit\n    }, {\n      'class': 'fc-cell-text'\n    }, core.htmlEscape(text));\n    return {\n      text: text,\n      spanHtml: spanHtml,\n      date: date,\n      colspan: 1,\n      isWeekStart: false\n    };\n  }\n\n  var TimelineNowIndicator =\n  /** @class */\n  function () {\n    function TimelineNowIndicator(headParent, bodyParent) {\n      this.headParent = headParent;\n      this.bodyParent = bodyParent;\n    }\n\n    TimelineNowIndicator.prototype.render = function (coord, isRtl) {\n      var styleProps = isRtl ? {\n        right: -coord\n      } : {\n        left: coord\n      };\n      this.headParent.appendChild(this.arrowEl = core.createElement('div', {\n        className: 'fc-now-indicator fc-now-indicator-arrow',\n        style: styleProps\n      }));\n      this.bodyParent.appendChild(this.lineEl = core.createElement('div', {\n        className: 'fc-now-indicator fc-now-indicator-line',\n        style: styleProps\n      }));\n    };\n\n    TimelineNowIndicator.prototype.unrender = function () {\n      if (this.arrowEl) {\n        core.removeElement(this.arrowEl);\n      }\n\n      if (this.lineEl) {\n        core.removeElement(this.lineEl);\n      }\n    };\n\n    return TimelineNowIndicator;\n  }();\n\n  var STICKY_PROP_VAL = computeStickyPropVal(); // if null, means not supported at all\n\n  var IS_MS_EDGE = /Edge/.test(navigator.userAgent);\n  var IS_SAFARI = STICKY_PROP_VAL === '-webkit-sticky'; // good b/c doesn't confuse chrome\n\n  var STICKY_CLASSNAME = 'fc-sticky';\n  /*\n  useful beyond the native position:sticky for these reasons:\n  - support in IE11\n  - nice centering support\n  */\n\n  var StickyScroller =\n  /** @class */\n  function () {\n    function StickyScroller(scroller, isRtl, isVertical) {\n      var _this = this;\n\n      this.usingRelative = null;\n      /*\n      known bug: called twice on init. problem when mixing with ScrollJoiner\n      */\n\n      this.updateSize = function () {\n        var els = Array.prototype.slice.call(_this.scroller.canvas.el.querySelectorAll('.' + STICKY_CLASSNAME));\n\n        var elGeoms = _this.queryElGeoms(els);\n\n        var viewportWidth = _this.scroller.el.clientWidth;\n\n        if (_this.usingRelative) {\n          var elDestinations = _this.computeElDestinations(elGeoms, viewportWidth); // read before prepPositioning\n\n\n          assignRelativePositions(els, elGeoms, elDestinations);\n        } else {\n          assignStickyPositions(els, elGeoms, viewportWidth);\n        }\n      };\n\n      this.scroller = scroller;\n      this.usingRelative = !STICKY_PROP_VAL || // IE11\n      IS_MS_EDGE && isRtl || // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/18883305/\n      (IS_MS_EDGE || IS_SAFARI) && isVertical; // because doesn't work with rowspan in tables, our only vertial use\n\n      if (this.usingRelative) {\n        scroller.on('scrollEnd', this.updateSize);\n      }\n    }\n\n    StickyScroller.prototype.destroy = function () {\n      this.scroller.off('scrollEnd', this.updateSize);\n    };\n\n    StickyScroller.prototype.queryElGeoms = function (els) {\n      var canvasOrigin = this.scroller.canvas.el.getBoundingClientRect();\n      var elGeoms = [];\n\n      for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {\n        var el = els_1[_i];\n        var parentBound = core.translateRect(el.parentNode.getBoundingClientRect(), -canvasOrigin.left, -canvasOrigin.top);\n        var elRect = el.getBoundingClientRect();\n        var computedStyles = window.getComputedStyle(el);\n        var computedTextAlign = window.getComputedStyle(el.parentNode).textAlign; // ask the parent\n\n        var intendedTextAlign = computedTextAlign;\n        var naturalBound = null;\n\n        if (computedStyles.position !== 'sticky') {\n          naturalBound = core.translateRect(elRect, -canvasOrigin.left - (parseFloat(computedStyles.left) || 0), // could be 'auto'\n          -canvasOrigin.top - (parseFloat(computedStyles.top) || 0));\n        }\n\n        if (el.hasAttribute('data-sticky-center')) {\n          intendedTextAlign = 'center';\n        }\n\n        elGeoms.push({\n          parentBound: parentBound,\n          naturalBound: naturalBound,\n          elWidth: elRect.width,\n          elHeight: elRect.height,\n          computedTextAlign: computedTextAlign,\n          intendedTextAlign: intendedTextAlign\n        });\n      }\n\n      return elGeoms;\n    };\n\n    StickyScroller.prototype.computeElDestinations = function (elGeoms, viewportWidth) {\n      var viewportLeft = this.scroller.getScrollFromLeft();\n      var viewportTop = this.scroller.getScrollTop();\n      var viewportRight = viewportLeft + viewportWidth;\n      return elGeoms.map(function (elGeom) {\n        var elWidth = elGeom.elWidth,\n            elHeight = elGeom.elHeight,\n            parentBound = elGeom.parentBound,\n            naturalBound = elGeom.naturalBound;\n        var destLeft; // relative to canvas topleft\n\n        var destTop; // \"\n\n        switch (elGeom.intendedTextAlign) {\n          case 'left':\n            destLeft = viewportLeft;\n            break;\n\n          case 'right':\n            destLeft = viewportRight - elWidth;\n            break;\n\n          case 'center':\n            destLeft = (viewportLeft + viewportRight) / 2 - elWidth / 2;\n            break;\n        }\n\n        destLeft = Math.min(destLeft, parentBound.right - elWidth);\n        destLeft = Math.max(destLeft, parentBound.left);\n        destTop = viewportTop;\n        destTop = Math.min(destTop, parentBound.bottom - elHeight);\n        destTop = Math.max(destTop, naturalBound.top); // better to use natural top for upper bound\n\n        return {\n          left: destLeft,\n          top: destTop\n        };\n      });\n    };\n\n    return StickyScroller;\n  }();\n\n  function assignRelativePositions(els, elGeoms, elDestinations) {\n    els.forEach(function (el, i) {\n      var naturalBound = elGeoms[i].naturalBound;\n      core.applyStyle(el, {\n        position: 'relative',\n        left: elDestinations[i].left - naturalBound.left,\n        top: elDestinations[i].top - naturalBound.top\n      });\n    });\n  }\n\n  function assignStickyPositions(els, elGeoms, viewportWidth) {\n    els.forEach(function (el, i) {\n      var stickyLeft = 0;\n\n      if (elGeoms[i].intendedTextAlign === 'center') {\n        stickyLeft = (viewportWidth - elGeoms[i].elWidth) / 2; // needs to be forced to left?\n\n        if (elGeoms[i].computedTextAlign === 'center') {\n          el.setAttribute('data-sticky-center', '') // remember for next queryElGeoms\n          ;\n          el.parentNode.style.textAlign = 'left';\n        }\n      }\n\n      core.applyStyle(el, {\n        position: STICKY_PROP_VAL,\n        left: stickyLeft,\n        right: 0,\n        top: 0\n      });\n    });\n  }\n\n  function computeStickyPropVal() {\n    var el = core.htmlToElement('<div style=\"position:-webkit-sticky;position:sticky\"></div>');\n    var val = el.style.position;\n\n    if (val.indexOf('sticky') !== -1) {\n      return val;\n    } else {\n      return null;\n    }\n  }\n\n  var TimeAxis =\n  /** @class */\n  function (_super) {\n    __extends(TimeAxis, _super);\n\n    function TimeAxis(context, headerContainerEl, bodyContainerEl) {\n      var _this = _super.call(this, context) || this;\n\n      var layout = _this.layout = new HeaderBodyLayout(headerContainerEl, bodyContainerEl, 'auto');\n      var headerEnhancedScroller = layout.headerScroller.enhancedScroll;\n      var bodyEnhancedScroller = layout.bodyScroller.enhancedScroll; // needs to go after layout, which has ScrollJoiner\n\n      _this.headStickyScroller = new StickyScroller(headerEnhancedScroller, _this.isRtl, false); // isVertical=false\n\n      _this.bodyStickyScroller = new StickyScroller(bodyEnhancedScroller, _this.isRtl, false); // isVertical=false\n\n      _this.header = new TimelineHeader(context, headerEnhancedScroller.canvas.contentEl);\n      _this.slats = new TimelineSlats(context, bodyEnhancedScroller.canvas.bgEl);\n      _this.nowIndicator = new TimelineNowIndicator(headerEnhancedScroller.canvas.el, bodyEnhancedScroller.canvas.el);\n      return _this;\n    }\n\n    TimeAxis.prototype.destroy = function () {\n      this.layout.destroy();\n      this.header.destroy();\n      this.slats.destroy();\n      this.nowIndicator.unrender();\n      this.headStickyScroller.destroy();\n      this.bodyStickyScroller.destroy();\n\n      _super.prototype.destroy.call(this);\n    };\n\n    TimeAxis.prototype.render = function (props) {\n      var tDateProfile = this.tDateProfile = buildTimelineDateProfile(props.dateProfile, this.view); // TODO: cache\n\n      this.header.receiveProps({\n        dateProfile: props.dateProfile,\n        tDateProfile: tDateProfile\n      });\n      this.slats.receiveProps({\n        dateProfile: props.dateProfile,\n        tDateProfile: tDateProfile\n      });\n    }; // Now Indicator\n    // ------------------------------------------------------------------------------------------\n\n\n    TimeAxis.prototype.getNowIndicatorUnit = function (dateProfile) {\n      // yuck\n      var tDateProfile = this.tDateProfile = buildTimelineDateProfile(dateProfile, this.view); // TODO: cache\n\n      if (tDateProfile.isTimeScale) {\n        return core.greatestDurationDenominator(tDateProfile.slotDuration).unit;\n      }\n    }; // will only execute if isTimeScale\n\n\n    TimeAxis.prototype.renderNowIndicator = function (date) {\n      if (core.rangeContainsMarker(this.tDateProfile.normalizedRange, date)) {\n        this.nowIndicator.render(this.dateToCoord(date), this.isRtl);\n      }\n    }; // will only execute if isTimeScale\n\n\n    TimeAxis.prototype.unrenderNowIndicator = function () {\n      this.nowIndicator.unrender();\n    }; // Sizing\n    // ------------------------------------------------------------------------------------------\n\n\n    TimeAxis.prototype.updateSize = function (isResize, totalHeight, isAuto) {\n      this.applySlotWidth(this.computeSlotWidth()); // adjusts gutters. do after slot widths set\n\n      this.layout.setHeight(totalHeight, isAuto); // pretty much just queries coords. do last\n\n      this.slats.updateSize();\n    };\n\n    TimeAxis.prototype.updateStickyScrollers = function () {\n      this.headStickyScroller.updateSize();\n      this.bodyStickyScroller.updateSize();\n    };\n\n    TimeAxis.prototype.computeSlotWidth = function () {\n      var slotWidth = this.opt('slotWidth') || '';\n\n      if (slotWidth === '') {\n        slotWidth = this.computeDefaultSlotWidth(this.tDateProfile);\n      }\n\n      return slotWidth;\n    };\n\n    TimeAxis.prototype.computeDefaultSlotWidth = function (tDateProfile) {\n      var maxInnerWidth = 0; // TODO: harness core's `matchCellWidths` for this\n\n      this.header.innerEls.forEach(function (innerEl, i) {\n        maxInnerWidth = Math.max(maxInnerWidth, innerEl.getBoundingClientRect().width);\n      });\n      var headingCellWidth = Math.ceil(maxInnerWidth) + 1; // assume no padding, and one pixel border\n      // in TimelineView.defaults we ensured that labelInterval is an interval of slotDuration\n      // TODO: rename labelDuration?\n\n      var slotsPerLabel = core.wholeDivideDurations(tDateProfile.labelInterval, tDateProfile.slotDuration);\n      var slotWidth = Math.ceil(headingCellWidth / slotsPerLabel);\n      var minWidth = window.getComputedStyle(this.header.slatColEls[0]).minWidth;\n\n      if (minWidth) {\n        minWidth = parseInt(minWidth, 10);\n\n        if (minWidth) {\n          slotWidth = Math.max(slotWidth, minWidth);\n        }\n      }\n\n      return slotWidth;\n    };\n\n    TimeAxis.prototype.applySlotWidth = function (slotWidth) {\n      var _a = this,\n          layout = _a.layout,\n          tDateProfile = _a.tDateProfile;\n\n      var containerWidth = '';\n      var containerMinWidth = '';\n      var nonLastSlotWidth = '';\n\n      if (slotWidth !== '') {\n        slotWidth = Math.round(slotWidth);\n        containerWidth = slotWidth * tDateProfile.slotDates.length;\n        containerMinWidth = '';\n        nonLastSlotWidth = slotWidth;\n        var availableWidth = layout.bodyScroller.enhancedScroll.getClientWidth();\n\n        if (availableWidth > containerWidth) {\n          containerMinWidth = availableWidth;\n          containerWidth = '';\n          nonLastSlotWidth = Math.floor(availableWidth / tDateProfile.slotDates.length);\n        }\n      }\n\n      layout.headerScroller.enhancedScroll.canvas.setWidth(containerWidth);\n      layout.headerScroller.enhancedScroll.canvas.setMinWidth(containerMinWidth);\n      layout.bodyScroller.enhancedScroll.canvas.setWidth(containerWidth);\n      layout.bodyScroller.enhancedScroll.canvas.setMinWidth(containerMinWidth);\n\n      if (nonLastSlotWidth !== '') {\n        this.header.slatColEls.slice(0, -1).concat(this.slats.slatColEls.slice(0, -1)).forEach(function (el) {\n          el.style.width = nonLastSlotWidth + 'px';\n        });\n      }\n    }; // returned value is between 0 and the number of snaps\n\n\n    TimeAxis.prototype.computeDateSnapCoverage = function (date) {\n      var _a = this,\n          dateEnv = _a.dateEnv,\n          tDateProfile = _a.tDateProfile;\n\n      var snapDiff = dateEnv.countDurationsBetween(tDateProfile.normalizedRange.start, date, tDateProfile.snapDuration);\n\n      if (snapDiff < 0) {\n        return 0;\n      } else if (snapDiff >= tDateProfile.snapDiffToIndex.length) {\n        return tDateProfile.snapCnt;\n      } else {\n        var snapDiffInt = Math.floor(snapDiff);\n        var snapCoverage = tDateProfile.snapDiffToIndex[snapDiffInt];\n\n        if (core.isInt(snapCoverage)) {\n          // not an in-between value\n          snapCoverage += snapDiff - snapDiffInt; // add the remainder\n        } else {\n          // a fractional value, meaning the date is not visible\n          // always round up in this case. works for start AND end dates in a range.\n          snapCoverage = Math.ceil(snapCoverage);\n        }\n\n        return snapCoverage;\n      }\n    }; // for LTR, results range from 0 to width of area\n    // for RTL, results range from negative width of area to 0\n\n\n    TimeAxis.prototype.dateToCoord = function (date) {\n      var tDateProfile = this.tDateProfile;\n      var snapCoverage = this.computeDateSnapCoverage(date);\n      var slotCoverage = snapCoverage / tDateProfile.snapsPerSlot;\n      var slotIndex = Math.floor(slotCoverage);\n      slotIndex = Math.min(slotIndex, tDateProfile.slotCnt - 1);\n      var partial = slotCoverage - slotIndex;\n      var _a = this.slats,\n          innerCoordCache = _a.innerCoordCache,\n          outerCoordCache = _a.outerCoordCache;\n\n      if (this.isRtl) {\n        return outerCoordCache.rights[slotIndex] - innerCoordCache.getWidth(slotIndex) * partial - outerCoordCache.originClientRect.width;\n      } else {\n        return outerCoordCache.lefts[slotIndex] + innerCoordCache.getWidth(slotIndex) * partial;\n      }\n    };\n\n    TimeAxis.prototype.rangeToCoords = function (range) {\n      if (this.isRtl) {\n        return {\n          right: this.dateToCoord(range.start),\n          left: this.dateToCoord(range.end)\n        };\n      } else {\n        return {\n          left: this.dateToCoord(range.start),\n          right: this.dateToCoord(range.end)\n        };\n      }\n    }; // Scrolling\n    // ------------------------------------------------------------------------------------------\n\n\n    TimeAxis.prototype.computeDateScroll = function (timeMs) {\n      var dateEnv = this.dateEnv;\n      var dateProfile = this.props.dateProfile;\n      var left = 0;\n\n      if (dateProfile) {\n        left = this.dateToCoord(dateEnv.add(core.startOfDay(dateProfile.activeRange.start), // startOfDay needed?\n        core.createDuration(timeMs))); // hack to overcome the left borders of non-first slat\n\n        if (!this.isRtl && left) {\n          left += 1;\n        }\n      }\n\n      return {\n        left: left\n      };\n    };\n\n    TimeAxis.prototype.queryDateScroll = function () {\n      var enhancedScroll = this.layout.bodyScroller.enhancedScroll;\n      return {\n        left: enhancedScroll.getScrollLeft()\n      };\n    };\n\n    TimeAxis.prototype.applyDateScroll = function (scroll) {\n      // TODO: lame we have to update both. use the scrolljoiner instead maybe\n      this.layout.bodyScroller.enhancedScroll.setScrollLeft(scroll.left || 0);\n      this.layout.headerScroller.enhancedScroll.setScrollLeft(scroll.left || 0);\n    };\n\n    return TimeAxis;\n  }(core.Component); // import { computeResourceEditable } from '@fullcalendar/resource-common' ... CAN'T HAVE THIS DEP! COPIED AND PASTED BELOW!\n\n\n  var TimelineLaneEventRenderer =\n  /** @class */\n  function (_super) {\n    __extends(TimelineLaneEventRenderer, _super);\n\n    function TimelineLaneEventRenderer(context, masterContainerEl, timeAxis) {\n      var _this = _super.call(this, context) || this;\n\n      _this.masterContainerEl = masterContainerEl;\n      _this.timeAxis = timeAxis;\n      return _this;\n    }\n\n    TimelineLaneEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {\n      var eventRange = seg.eventRange;\n      var eventDef = eventRange.def;\n      var eventUi = eventRange.ui;\n      var isDraggable = eventUi.startEditable || computeResourceEditable(eventDef, this.timeAxis.calendar);\n      var isResizableFromStart = seg.isStart && eventUi.durationEditable && this.context.options.eventResizableFromStart;\n      var isResizableFromEnd = seg.isEnd && eventUi.durationEditable;\n      var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);\n      classes.unshift('fc-timeline-event', 'fc-h-event');\n      var timeText = this.getTimeText(eventRange);\n      return '<a class=\"' + classes.join(' ') + '\" style=\"' + core.cssToStr(this.getSkinCss(eventUi)) + '\"' + (eventDef.url ? ' href=\"' + core.htmlEscape(eventDef.url) + '\"' : '') + '>' + '<div class=\"fc-content\">' + (timeText ? '<span class=\"fc-time\">' + core.htmlEscape(timeText) + '</span>' : '') + '<span class=\"fc-title fc-sticky\">' + (eventDef.title ? core.htmlEscape(eventDef.title) : '&nbsp;') + '</span>' + '</div>' + (isResizableFromStart ? '<div class=\"fc-resizer fc-start-resizer\"></div>' : '') + (isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\"></div>' : '') + '</a>';\n    };\n\n    TimelineLaneEventRenderer.prototype.computeDisplayEventTime = function () {\n      return !this.timeAxis.tDateProfile.isTimeScale; // because times should be obvious via axis\n    };\n\n    TimelineLaneEventRenderer.prototype.computeDisplayEventEnd = function () {\n      return false;\n    }; // Computes a default event time formatting string if `timeFormat` is not explicitly defined\n\n\n    TimelineLaneEventRenderer.prototype.computeEventTimeFormat = function () {\n      return {\n        hour: 'numeric',\n        minute: '2-digit',\n        omitZeroMinute: true,\n        meridiem: 'narrow'\n      };\n    };\n\n    TimelineLaneEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n      if (!this.el && this.masterContainerEl) {\n        this.el = core.createElement('div', {\n          className: 'fc-event-container'\n        });\n\n        if (mirrorInfo) {\n          this.el.classList.add('fc-mirror-container');\n        }\n\n        this.masterContainerEl.appendChild(this.el);\n      }\n\n      if (this.el) {\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n          var seg = segs_1[_i];\n          this.el.appendChild(seg.el);\n        }\n      }\n    };\n\n    TimelineLaneEventRenderer.prototype.detachSegs = function (segs) {\n      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n        var seg = segs_2[_i];\n        core.removeElement(seg.el);\n      }\n    }; // computes AND assigns (assigns the left/right at least). bad\n\n\n    TimelineLaneEventRenderer.prototype.computeSegSizes = function (segs) {\n      var timeAxis = this.timeAxis;\n\n      for (var _i = 0, segs_3 = segs; _i < segs_3.length; _i++) {\n        var seg = segs_3[_i];\n        var coords = timeAxis.rangeToCoords(seg); // works because Seg has start/end\n\n        core.applyStyle(seg.el, {\n          left: seg.left = coords.left,\n          right: -(seg.right = coords.right)\n        });\n      }\n    };\n\n    TimelineLaneEventRenderer.prototype.assignSegSizes = function (segs) {\n      if (!this.el) {\n        return;\n      } // compute seg verticals\n\n\n      for (var _i = 0, segs_4 = segs; _i < segs_4.length; _i++) {\n        var seg = segs_4[_i];\n        seg.height = core.computeHeightAndMargins(seg.el);\n      }\n\n      this.buildSegLevels(segs); // populates above/below props for computeOffsetForSegs\n\n      var totalHeight = computeOffsetForSegs(segs); // also assigns seg.top\n\n      core.applyStyleProp(this.el, 'height', totalHeight); // assign seg verticals\n\n      for (var _a = 0, segs_5 = segs; _a < segs_5.length; _a++) {\n        var seg = segs_5[_a];\n        core.applyStyleProp(seg.el, 'top', seg.top);\n      }\n    };\n\n    TimelineLaneEventRenderer.prototype.buildSegLevels = function (segs) {\n      var segLevels = [];\n      segs = this.sortEventSegs(segs);\n\n      for (var _i = 0, segs_6 = segs; _i < segs_6.length; _i++) {\n        var unplacedSeg = segs_6[_i];\n        unplacedSeg.above = []; // determine the first level with no collisions\n\n        var level = 0; // level index\n\n        while (level < segLevels.length) {\n          var isLevelCollision = false; // determine collisions\n\n          for (var _a = 0, _b = segLevels[level]; _a < _b.length; _a++) {\n            var placedSeg = _b[_a];\n\n            if (timeRowSegsCollide(unplacedSeg, placedSeg)) {\n              unplacedSeg.above.push(placedSeg);\n              isLevelCollision = true;\n            }\n          }\n\n          if (isLevelCollision) {\n            level += 1;\n          } else {\n            break;\n          }\n        } // insert into the first non-colliding level. create if necessary\n\n\n        (segLevels[level] || (segLevels[level] = [])).push(unplacedSeg); // record possible colliding segments below (TODO: automated test for this)\n\n        level += 1;\n\n        while (level < segLevels.length) {\n          for (var _c = 0, _d = segLevels[level]; _c < _d.length; _c++) {\n            var belowSeg = _d[_c];\n\n            if (timeRowSegsCollide(unplacedSeg, belowSeg)) {\n              belowSeg.above.push(unplacedSeg);\n            }\n          }\n\n          level += 1;\n        }\n      }\n\n      return segLevels;\n    };\n\n    return TimelineLaneEventRenderer;\n  }(core.FgEventRenderer);\n\n  function computeOffsetForSegs(segs) {\n    var max = 0;\n\n    for (var _i = 0, segs_7 = segs; _i < segs_7.length; _i++) {\n      var seg = segs_7[_i];\n      max = Math.max(max, computeOffsetForSeg(seg));\n    }\n\n    return max;\n  }\n\n  function computeOffsetForSeg(seg) {\n    if (seg.top == null) {\n      seg.top = computeOffsetForSegs(seg.above);\n    }\n\n    return seg.top + seg.height;\n  }\n\n  function timeRowSegsCollide(seg0, seg1) {\n    return seg0.left < seg1.right && seg0.right > seg1.left;\n  } // HACK\n\n\n  function computeResourceEditable(eventDef, calendar) {\n    var resourceEditable = eventDef.resourceEditable;\n\n    if (resourceEditable == null) {\n      var source = eventDef.sourceId && calendar.state.eventSources[eventDef.sourceId];\n\n      if (source) {\n        resourceEditable = source.extendedProps.resourceEditable; // used the Source::extendedProps hack\n      }\n\n      if (resourceEditable == null) {\n        resourceEditable = calendar.opt('eventResourceEditable');\n\n        if (resourceEditable == null) {\n          resourceEditable = true; // TODO: use defaults system instead\n        }\n      }\n    }\n\n    return resourceEditable;\n  }\n\n  var TimelineLaneFillRenderer =\n  /** @class */\n  function (_super) {\n    __extends(TimelineLaneFillRenderer, _super);\n\n    function TimelineLaneFillRenderer(context, masterContainerEl, timeAxis) {\n      var _this = _super.call(this, context) || this;\n\n      _this.masterContainerEl = masterContainerEl;\n      _this.timeAxis = timeAxis;\n      return _this;\n    }\n\n    TimelineLaneFillRenderer.prototype.attachSegs = function (type, segs) {\n      if (segs.length) {\n        var className = void 0;\n\n        if (type === 'businessHours') {\n          className = 'bgevent';\n        } else {\n          className = type.toLowerCase();\n        } // making a new container each time is OKAY\n        // all types of segs (background or business hours or whatever) are rendered in one pass\n\n\n        var containerEl = core.createElement('div', {\n          className: 'fc-' + className + '-container'\n        });\n        this.masterContainerEl.appendChild(containerEl);\n\n        for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n          var seg = segs_1[_i];\n          containerEl.appendChild(seg.el);\n        }\n\n        return [containerEl]; // return value\n      }\n    };\n\n    TimelineLaneFillRenderer.prototype.computeSegSizes = function (segs) {\n      var timeAxis = this.timeAxis;\n\n      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n        var seg = segs_2[_i];\n        var coords = timeAxis.rangeToCoords(seg);\n        seg.left = coords.left;\n        seg.right = coords.right;\n      }\n    };\n\n    TimelineLaneFillRenderer.prototype.assignSegSizes = function (segs) {\n      for (var _i = 0, segs_3 = segs; _i < segs_3.length; _i++) {\n        var seg = segs_3[_i];\n        core.applyStyle(seg.el, {\n          left: seg.left,\n          right: -seg.right\n        });\n      }\n    };\n\n    return TimelineLaneFillRenderer;\n  }(core.FillRenderer);\n\n  var TimelineLane =\n  /** @class */\n  function (_super) {\n    __extends(TimelineLane, _super);\n\n    function TimelineLane(context, fgContainerEl, bgContainerEl, timeAxis) {\n      var _this = _super.call(this, context, bgContainerEl) // should el be bgContainerEl???\n      || this;\n\n      _this.slicer = new TimelineLaneSlicer();\n      _this.renderEventDrag = core.memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag);\n      _this.renderEventResize = core.memoizeRendering(_this._renderEventResize, _this._unrenderEventResize);\n      var fillRenderer = _this.fillRenderer = new TimelineLaneFillRenderer(context, bgContainerEl, timeAxis);\n      var eventRenderer = _this.eventRenderer = new TimelineLaneEventRenderer(context, fgContainerEl, timeAxis);\n      _this.mirrorRenderer = new TimelineLaneEventRenderer(context, fgContainerEl, timeAxis);\n      _this.renderBusinessHours = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'));\n      _this.renderDateSelection = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'highlight'), fillRenderer.unrender.bind(fillRenderer, 'highlight'));\n      _this.renderBgEvents = core.memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'));\n      _this.renderFgEvents = core.memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer));\n      _this.renderEventSelection = core.memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n      _this.timeAxis = timeAxis;\n      return _this;\n    }\n\n    TimelineLane.prototype.render = function (props) {\n      var slicedProps = this.slicer.sliceProps(props, props.dateProfile, this.timeAxis.tDateProfile.isTimeScale ? null : props.nextDayThreshold, this, this.timeAxis);\n      this.renderBusinessHours(slicedProps.businessHourSegs);\n      this.renderDateSelection(slicedProps.dateSelectionSegs);\n      this.renderBgEvents(slicedProps.bgEventSegs);\n      this.renderFgEvents(slicedProps.fgEventSegs);\n      this.renderEventSelection(slicedProps.eventSelection);\n      this.renderEventDrag(slicedProps.eventDrag);\n      this.renderEventResize(slicedProps.eventResize);\n    };\n\n    TimelineLane.prototype.destroy = function () {\n      _super.prototype.destroy.call(this);\n\n      this.renderBusinessHours.unrender();\n      this.renderDateSelection.unrender();\n      this.renderBgEvents.unrender();\n      this.renderFgEvents.unrender();\n      this.renderEventSelection.unrender();\n      this.renderEventDrag.unrender();\n      this.renderEventResize.unrender();\n    };\n\n    TimelineLane.prototype._renderEventDrag = function (state) {\n      if (state) {\n        this.eventRenderer.hideByHash(state.affectedInstances);\n        this.mirrorRenderer.renderSegs(state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      }\n    };\n\n    TimelineLane.prototype._unrenderEventDrag = function (state) {\n      if (state) {\n        this.eventRenderer.showByHash(state.affectedInstances);\n        this.mirrorRenderer.unrender(state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      }\n    };\n\n    TimelineLane.prototype._renderEventResize = function (state) {\n      if (state) {\n        // HACK. eventRenderer and fillRenderer both use these segs. would compete over seg.el\n        var segsForHighlight = state.segs.map(function (seg) {\n          return __assign({}, seg);\n        });\n        this.eventRenderer.hideByHash(state.affectedInstances);\n        this.fillRenderer.renderSegs('highlight', segsForHighlight);\n        this.mirrorRenderer.renderSegs(state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      }\n    };\n\n    TimelineLane.prototype._unrenderEventResize = function (state) {\n      if (state) {\n        this.eventRenderer.showByHash(state.affectedInstances);\n        this.fillRenderer.unrender('highlight');\n        this.mirrorRenderer.unrender(state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      }\n    };\n\n    TimelineLane.prototype.updateSize = function (isResize) {\n      var _a = this,\n          fillRenderer = _a.fillRenderer,\n          eventRenderer = _a.eventRenderer,\n          mirrorRenderer = _a.mirrorRenderer;\n\n      fillRenderer.computeSizes(isResize);\n      eventRenderer.computeSizes(isResize);\n      mirrorRenderer.computeSizes(isResize);\n      fillRenderer.assignSizes(isResize);\n      eventRenderer.assignSizes(isResize);\n      mirrorRenderer.assignSizes(isResize);\n    };\n\n    return TimelineLane;\n  }(core.DateComponent);\n\n  var TimelineLaneSlicer =\n  /** @class */\n  function (_super) {\n    __extends(TimelineLaneSlicer, _super);\n\n    function TimelineLaneSlicer() {\n      return _super !== null && _super.apply(this, arguments) || this;\n    }\n\n    TimelineLaneSlicer.prototype.sliceRange = function (origRange, timeAxis) {\n      var tDateProfile = timeAxis.tDateProfile;\n      var dateProfile = timeAxis.props.dateProfile;\n      var normalRange = normalizeRange(origRange, tDateProfile, timeAxis.dateEnv);\n      var segs = []; // protect against when the span is entirely in an invalid date region\n\n      if (timeAxis.computeDateSnapCoverage(normalRange.start) < timeAxis.computeDateSnapCoverage(normalRange.end)) {\n        // intersect the footprint's range with the grid's range\n        var slicedRange = core.intersectRanges(normalRange, tDateProfile.normalizedRange);\n\n        if (slicedRange) {\n          segs.push({\n            start: slicedRange.start,\n            end: slicedRange.end,\n            isStart: slicedRange.start.valueOf() === normalRange.start.valueOf() && isValidDate(slicedRange.start, tDateProfile, dateProfile, timeAxis.view),\n            isEnd: slicedRange.end.valueOf() === normalRange.end.valueOf() && isValidDate(core.addMs(slicedRange.end, -1), tDateProfile, dateProfile, timeAxis.view)\n          });\n        }\n      }\n\n      return segs;\n    };\n\n    return TimelineLaneSlicer;\n  }(core.Slicer);\n\n  var TimelineView =\n  /** @class */\n  function (_super) {\n    __extends(TimelineView, _super);\n\n    function TimelineView(context, viewSpec, dateProfileGenerator, parentEl) {\n      var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;\n\n      _this.el.classList.add('fc-timeline');\n\n      if (_this.opt('eventOverlap') === false) {\n        _this.el.classList.add('fc-no-overlap');\n      }\n\n      _this.el.innerHTML = _this.renderSkeletonHtml();\n      _this.timeAxis = new TimeAxis(_this.context, _this.el.querySelector('thead .fc-time-area'), _this.el.querySelector('tbody .fc-time-area'));\n      _this.lane = new TimelineLane(_this.context, _this.timeAxis.layout.bodyScroller.enhancedScroll.canvas.contentEl, _this.timeAxis.layout.bodyScroller.enhancedScroll.canvas.bgEl, _this.timeAxis);\n      context.calendar.registerInteractiveComponent(_this, {\n        el: _this.timeAxis.slats.el\n      });\n      return _this;\n    }\n\n    TimelineView.prototype.destroy = function () {\n      this.timeAxis.destroy();\n      this.lane.destroy();\n\n      _super.prototype.destroy.call(this);\n\n      this.calendar.unregisterInteractiveComponent(this);\n    };\n\n    TimelineView.prototype.renderSkeletonHtml = function () {\n      var theme = this.theme;\n      return \"<table class=\\\"\" + theme.getClass('tableGrid') + \"\\\"> <thead class=\\\"fc-head\\\"> <tr> <td class=\\\"fc-time-area \" + theme.getClass('widgetHeader') + \"\\\"></td> </tr> </thead> <tbody class=\\\"fc-body\\\"> <tr> <td class=\\\"fc-time-area \" + theme.getClass('widgetContent') + \"\\\"></td> </tr> </tbody> </table>\";\n    };\n\n    TimelineView.prototype.render = function (props) {\n      _super.prototype.render.call(this, props); // flags for updateSize, addScroll\n\n\n      this.timeAxis.receiveProps({\n        dateProfile: props.dateProfile\n      });\n      this.lane.receiveProps(__assign({}, props, {\n        nextDayThreshold: this.nextDayThreshold\n      }));\n    };\n\n    TimelineView.prototype.updateSize = function (isResize, totalHeight, isAuto) {\n      this.timeAxis.updateSize(isResize, totalHeight, isAuto);\n      this.lane.updateSize(isResize);\n    }; // Now Indicator\n    // ------------------------------------------------------------------------------------------\n\n\n    TimelineView.prototype.getNowIndicatorUnit = function (dateProfile) {\n      return this.timeAxis.getNowIndicatorUnit(dateProfile);\n    };\n\n    TimelineView.prototype.renderNowIndicator = function (date) {\n      this.timeAxis.renderNowIndicator(date);\n    };\n\n    TimelineView.prototype.unrenderNowIndicator = function () {\n      this.timeAxis.unrenderNowIndicator();\n    }; // Scroll System\n    // ------------------------------------------------------------------------------------------\n\n\n    TimelineView.prototype.computeDateScroll = function (timeMs) {\n      return this.timeAxis.computeDateScroll(timeMs);\n    };\n\n    TimelineView.prototype.applyScroll = function (scroll, isResize) {\n      _super.prototype.applyScroll.call(this, scroll, isResize); // will call applyDateScroll\n      // avoid updating stickyscroll too often\n      // TODO: repeat code as ResourceTimelineView::updateSize\n\n\n      var calendar = this.calendar;\n\n      if (isResize || calendar.isViewUpdated || calendar.isDatesUpdated || calendar.isEventsUpdated) {\n        this.timeAxis.updateStickyScrollers();\n      }\n    };\n\n    TimelineView.prototype.applyDateScroll = function (scroll) {\n      this.timeAxis.applyDateScroll(scroll);\n    };\n\n    TimelineView.prototype.queryScroll = function () {\n      var enhancedScroll = this.timeAxis.layout.bodyScroller.enhancedScroll;\n      return {\n        top: enhancedScroll.getScrollTop(),\n        left: enhancedScroll.getScrollLeft()\n      };\n    }; // Hit System\n    // ------------------------------------------------------------------------------------------\n\n\n    TimelineView.prototype.buildPositionCaches = function () {\n      this.timeAxis.slats.updateSize();\n    };\n\n    TimelineView.prototype.queryHit = function (positionLeft, positionTop, elWidth, elHeight) {\n      var slatHit = this.timeAxis.slats.positionToHit(positionLeft);\n\n      if (slatHit) {\n        return {\n          component: this,\n          dateSpan: slatHit.dateSpan,\n          rect: {\n            left: slatHit.left,\n            right: slatHit.right,\n            top: 0,\n            bottom: elHeight\n          },\n          dayEl: slatHit.dayEl,\n          layer: 0\n        };\n      }\n    };\n\n    return TimelineView;\n  }(core.View);\n\n  var main = core.createPlugin({\n    defaultView: 'timelineDay',\n    views: {\n      timeline: {\n        class: TimelineView,\n        eventResizableFromStart: true // how is this consumed for TimelineView tho?\n\n      },\n      timelineDay: {\n        type: 'timeline',\n        duration: {\n          days: 1\n        }\n      },\n      timelineWeek: {\n        type: 'timeline',\n        duration: {\n          weeks: 1\n        }\n      },\n      timelineMonth: {\n        type: 'timeline',\n        duration: {\n          months: 1\n        }\n      },\n      timelineYear: {\n        type: 'timeline',\n        duration: {\n          years: 1\n        }\n      }\n    }\n  });\n  exports.HeaderBodyLayout = HeaderBodyLayout;\n  exports.ScrollJoiner = ScrollJoiner;\n  exports.StickyScroller = StickyScroller;\n  exports.TimeAxis = TimeAxis;\n  exports.TimelineLane = TimelineLane;\n  exports.TimelineView = TimelineView;\n  exports.default = main;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}