{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport EventListener from 'react-event-listener';\nimport debounce from 'debounce'; // < 1kb payload overhead when lodash/debounce is > 3kb.\n\nimport { getDisplayName } from '@material-ui/utils';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport withTheme from '../styles/withTheme';\nimport { keys as breakpointKeys } from '../styles/createBreakpoints';\nimport getThemeProps from '../styles/getThemeProps'; // By default, returns true if screen width is the same or greater than the given breakpoint.\n\nexport const isWidthUp = (breakpoint, width, inclusive = true) => {\n  if (inclusive) {\n    return breakpointKeys.indexOf(breakpoint) <= breakpointKeys.indexOf(width);\n  }\n\n  return breakpointKeys.indexOf(breakpoint) < breakpointKeys.indexOf(width);\n}; // By default, returns true if screen width is the same or less than the given breakpoint.\n\nexport const isWidthDown = (breakpoint, width, inclusive = true) => {\n  if (inclusive) {\n    return breakpointKeys.indexOf(width) <= breakpointKeys.indexOf(breakpoint);\n  }\n\n  return breakpointKeys.indexOf(width) < breakpointKeys.indexOf(breakpoint);\n};\n\nconst withWidth = (options = {}) => Component => {\n  const _options$withTheme = options.withTheme,\n        withThemeOption = _options$withTheme === void 0 ? false : _options$withTheme,\n        _options$noSSR = options.noSSR,\n        noSSR = _options$noSSR === void 0 ? false : _options$noSSR,\n        initialWidthOption = options.initialWidth,\n        _options$resizeInterv = options.resizeInterval,\n        resizeInterval = _options$resizeInterv === void 0 ? 166 : _options$resizeInterv;\n\n  class WithWidth extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = {\n        width: noSSR ? this.getWidth() : undefined\n      };\n\n      if (typeof window !== 'undefined') {\n        this.handleResize = debounce(() => {\n          const width2 = this.getWidth();\n\n          if (width2 !== this.state.width) {\n            this.setState({\n              width: width2\n            });\n          }\n        }, resizeInterval);\n      }\n    }\n\n    componentDidMount() {\n      const width = this.getWidth();\n\n      if (width !== this.state.width) {\n        this.setState({\n          width\n        });\n      }\n    }\n\n    componentWillUnmount() {\n      this.handleResize.clear();\n    }\n\n    getWidth(innerWidth = window.innerWidth) {\n      const breakpoints = this.props.theme.breakpoints;\n      let width = null;\n      /**\n       * Start with the slowest value as low end devices often have a small screen.\n       *\n       * innerWidth |xs      sm      md      lg      xl\n       *            |-------|-------|-------|-------|------>\n       * width      |  xs   |  sm   |  md   |  lg   |  xl\n       */\n\n      let index = 1;\n\n      while (width === null && index < breakpointKeys.length) {\n        const currentWidth = breakpointKeys[index]; // @media are inclusive, so reproduce the behavior here.\n\n        if (innerWidth < breakpoints.values[currentWidth]) {\n          width = breakpointKeys[index - 1];\n          break;\n        }\n\n        index += 1;\n      }\n\n      width = width || 'xl';\n      return width;\n    }\n\n    render() {\n      const _getThemeProps = getThemeProps({\n        theme: this.props.theme,\n        name: 'MuiWithWidth',\n        props: _extends({}, this.props)\n      }),\n            initialWidth = _getThemeProps.initialWidth,\n            theme = _getThemeProps.theme,\n            width = _getThemeProps.width,\n            other = _objectWithoutPropertiesLoose(_getThemeProps, [\"initialWidth\", \"theme\", \"width\"]);\n\n      const more = _extends({\n        width: width || this.state.width || initialWidth || initialWidthOption\n      }, other); // When rendering the component on the server,\n      // we have no idea about the client browser screen width.\n      // In order to prevent blinks and help the reconciliation of the React tree\n      // we are not rendering the child component.\n      //\n      // An alternative is to use the `initialWidth` property.\n\n\n      if (more.width === undefined) {\n        return null;\n      }\n\n      if (withThemeOption) {\n        more.theme = theme;\n      }\n\n      return React.createElement(React.Fragment, null, React.createElement(Component, more), React.createElement(EventListener, {\n        target: \"window\",\n        onResize: this.handleResize\n      }));\n    }\n\n  }\n\n  process.env.NODE_ENV !== \"production\" ? WithWidth.propTypes = {\n    /**\n     * As `window.innerWidth` is unavailable on the server,\n     * we default to rendering an empty component during the first mount.\n     * You might want to use an heuristic to approximate\n     * the screen width of the client browser screen width.\n     *\n     * For instance, you could be using the user-agent or the client-hints.\n     * https://caniuse.com/#search=client%20hint\n     */\n    initialWidth: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl']),\n\n    /**\n     * @ignore\n     */\n    theme: PropTypes.object.isRequired,\n\n    /**\n     * Bypass the width calculation logic.\n     */\n    width: PropTypes.oneOf(['xs', 'sm', 'md', 'lg', 'xl'])\n  } : void 0;\n\n  if (process.env.NODE_ENV !== 'production') {\n    WithWidth.displayName = \"WithWidth(\".concat(getDisplayName(Component), \")\");\n  }\n\n  hoistNonReactStatics(WithWidth, Component);\n  return withTheme()(WithWidth);\n};\n\nexport default withWidth;","map":null,"metadata":{},"sourceType":"module"}