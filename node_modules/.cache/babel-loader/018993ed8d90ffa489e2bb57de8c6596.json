{"ast":null,"code":"/*!\nFullCalendar Resources Common Plugin v4.3.1\nDocs & License: https://fullcalendar.io/scheduler\n(c) 2019 Adam Shaw\n*/\nimport { memoize, filterHash, rangesIntersect, memoizeOutput, isPropsEqual, mapHash, combineEventUis, refineProps, rangesEqual, processScopedUiProps, parseBusinessHours, EventApi, Calendar, Splitter, mergeEventStores, isPropsValid, appendToElement, htmlEscape, cssToStr, config, isValidDate, addDays, unpromisify, requestJson, htmlToElement, removeElement, createFormatter, computeFallbackHeaderFormat, renderDateCell, findElements, Component, flexibleCompare, compareByFieldSpecs, createPlugin } from '@fullcalendar/core';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction massageEventDragMutation(eventMutation, hit0, hit1) {\n  var resource0 = hit0.dateSpan.resourceId;\n  var resource1 = hit1.dateSpan.resourceId;\n\n  if (resource0 && resource1 && resource0 !== resource1) {\n    eventMutation.resourceMutation = {\n      matchResourceId: resource0,\n      setResourceId: resource1\n    };\n  }\n}\n/*\nTODO: all this would be much easier if we were using a hash!\n*/\n\n\nfunction applyEventDefMutation(eventDef, mutation, calendar) {\n  var resourceMutation = mutation.resourceMutation;\n\n  if (resourceMutation && computeResourceEditable(eventDef, calendar)) {\n    var index = eventDef.resourceIds.indexOf(resourceMutation.matchResourceId);\n\n    if (index !== -1) {\n      var resourceIds = eventDef.resourceIds.slice(); // copy\n\n      resourceIds.splice(index, 1); // remove\n\n      if (resourceIds.indexOf(resourceMutation.setResourceId) === -1) {\n        // not already in there\n        resourceIds.push(resourceMutation.setResourceId); // add\n      }\n\n      eventDef.resourceIds = resourceIds;\n    }\n  }\n}\n/*\nHACK\nTODO: use EventUi system instead of this\n*/\n\n\nfunction computeResourceEditable(eventDef, calendar) {\n  var resourceEditable = eventDef.resourceEditable;\n\n  if (resourceEditable == null) {\n    var source = eventDef.sourceId && calendar.state.eventSources[eventDef.sourceId];\n\n    if (source) {\n      resourceEditable = source.extendedProps.resourceEditable; // used the Source::extendedProps hack\n    }\n\n    if (resourceEditable == null) {\n      resourceEditable = calendar.opt('eventResourceEditable');\n\n      if (resourceEditable == null) {\n        resourceEditable = calendar.opt('editable'); // TODO: use defaults system instead\n      }\n    }\n  }\n\n  return resourceEditable;\n}\n\nfunction transformEventDrop(mutation, calendar) {\n  var resourceMutation = mutation.resourceMutation;\n\n  if (resourceMutation) {\n    return {\n      oldResource: calendar.getResourceById(resourceMutation.matchResourceId),\n      newResource: calendar.getResourceById(resourceMutation.setResourceId)\n    };\n  } else {\n    return {\n      oldResource: null,\n      newResource: null\n    };\n  }\n}\n\nvar ResourceDataAdder =\n/** @class */\nfunction () {\n  function ResourceDataAdder() {\n    this.filterResources = memoize(filterResources);\n  }\n\n  ResourceDataAdder.prototype.transform = function (viewProps, viewSpec, calendarProps, view) {\n    if (viewSpec.class.needsResourceData) {\n      return {\n        resourceStore: this.filterResources(calendarProps.resourceStore, view.opt('filterResourcesWithEvents'), calendarProps.eventStore, calendarProps.dateProfile.activeRange),\n        resourceEntityExpansions: calendarProps.resourceEntityExpansions\n      };\n    }\n  };\n\n  return ResourceDataAdder;\n}();\n\nfunction filterResources(resourceStore, doFilterResourcesWithEvents, eventStore, activeRange) {\n  if (doFilterResourcesWithEvents) {\n    var instancesInRange = filterEventInstancesInRange(eventStore.instances, activeRange);\n    var hasEvents_1 = computeHasEvents(instancesInRange, eventStore.defs);\n\n    __assign(hasEvents_1, computeAncestorHasEvents(hasEvents_1, resourceStore));\n\n    return filterHash(resourceStore, function (resource, resourceId) {\n      return hasEvents_1[resourceId];\n    });\n  } else {\n    return resourceStore;\n  }\n}\n\nfunction filterEventInstancesInRange(eventInstances, activeRange) {\n  return filterHash(eventInstances, function (eventInstance) {\n    return rangesIntersect(eventInstance.range, activeRange);\n  });\n}\n\nfunction computeHasEvents(eventInstances, eventDefs) {\n  var hasEvents = {};\n\n  for (var instanceId in eventInstances) {\n    var instance = eventInstances[instanceId];\n\n    for (var _i = 0, _a = eventDefs[instance.defId].resourceIds; _i < _a.length; _i++) {\n      var resourceId = _a[_i];\n      hasEvents[resourceId] = true;\n    }\n  }\n\n  return hasEvents;\n}\n/*\nmark resources as having events if any of their ancestors have them\nNOTE: resourceStore might not have all the resources that hasEvents{} has keyed\n*/\n\n\nfunction computeAncestorHasEvents(hasEvents, resourceStore) {\n  var res = {};\n\n  for (var resourceId in hasEvents) {\n    var resource = void 0;\n\n    while (resource = resourceStore[resourceId]) {\n      resourceId = resource.parentId; // now functioning as the parentId\n\n      if (resourceId) {\n        res[resourceId] = true;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return res;\n} // for when non-resource view should be given EventUi info (for event coloring/constraints based off of resource data)\n\n\nvar ResourceEventConfigAdder =\n/** @class */\nfunction () {\n  function ResourceEventConfigAdder() {\n    this.buildResourceEventUis = memoizeOutput(buildResourceEventUis, isPropsEqual);\n    this.injectResourceEventUis = memoize(injectResourceEventUis);\n  }\n\n  ResourceEventConfigAdder.prototype.transform = function (viewProps, viewSpec, calendarProps) {\n    if (!viewSpec.class.needsResourceData) {\n      // is a non-resource view?\n      return {\n        eventUiBases: this.injectResourceEventUis(viewProps.eventUiBases, viewProps.eventStore.defs, this.buildResourceEventUis(calendarProps.resourceStore))\n      };\n    }\n  };\n\n  return ResourceEventConfigAdder;\n}();\n\nfunction buildResourceEventUis(resourceStore) {\n  return mapHash(resourceStore, function (resource) {\n    return resource.ui;\n  });\n}\n\nfunction injectResourceEventUis(eventUiBases, eventDefs, resourceEventUis) {\n  return mapHash(eventUiBases, function (eventUi, defId) {\n    if (defId) {\n      // not the '' key\n      return injectResourceEventUi(eventUi, eventDefs[defId], resourceEventUis);\n    } else {\n      return eventUi;\n    }\n  });\n}\n\nfunction injectResourceEventUi(origEventUi, eventDef, resourceEventUis) {\n  var parts = []; // first resource takes precedence, which fights with the ordering of combineEventUis, thus the unshifts\n\n  for (var _i = 0, _a = eventDef.resourceIds; _i < _a.length; _i++) {\n    var resourceId = _a[_i];\n\n    if (resourceEventUis[resourceId]) {\n      parts.unshift(resourceEventUis[resourceId]);\n    }\n  }\n\n  parts.unshift(origEventUi);\n  return combineEventUis(parts);\n} // for making sure events that have editable resources are always draggable in resource views\n\n\nfunction transformIsDraggable(val, eventDef, eventUi, view) {\n  if (!val) {\n    if (view.viewSpec.class.needsResourceData) {\n      if (computeResourceEditable(eventDef, view.calendar)) {\n        return true;\n      }\n    }\n  }\n\n  return val;\n}\n\nvar RESOURCE_SOURCE_PROPS = {\n  id: String\n};\nvar defs = [];\nvar uid = 0;\n\nfunction registerResourceSourceDef(def) {\n  defs.push(def);\n}\n\nfunction getResourceSourceDef(id) {\n  return defs[id];\n}\n\nfunction doesSourceIgnoreRange(source) {\n  return Boolean(defs[source.sourceDefId].ignoreRange);\n}\n\nfunction parseResourceSource(input) {\n  for (var i = defs.length - 1; i >= 0; i--) {\n    // later-added plugins take precedence\n    var def = defs[i];\n    var meta = def.parseMeta(input);\n\n    if (meta) {\n      var res = parseResourceSourceProps(typeof input === 'object' && input ? input : {}, meta, i);\n      res._raw = input;\n      return res;\n    }\n  }\n\n  return null;\n}\n\nfunction parseResourceSourceProps(input, meta, sourceDefId) {\n  var props = refineProps(input, RESOURCE_SOURCE_PROPS);\n  props.sourceId = String(uid++);\n  props.sourceDefId = sourceDefId;\n  props.meta = meta;\n  props.publicId = props.id;\n  props.isFetching = false;\n  props.latestFetchId = '';\n  props.fetchRange = null;\n  delete props.id;\n  return props;\n}\n\nfunction reduceResourceSource(source, action, dateProfile, calendar) {\n  switch (action.type) {\n    case 'INIT':\n      return createSource(calendar.opt('resources'), calendar);\n\n    case 'RESET_RESOURCE_SOURCE':\n      return createSource(action.resourceSourceInput, calendar, true);\n\n    case 'PREV': // TODO: how do we track all actions that affect dateProfile :(\n\n    case 'NEXT':\n    case 'SET_DATE':\n    case 'SET_VIEW_TYPE':\n      return handleRange(source, dateProfile.activeRange, calendar);\n\n    case 'RECEIVE_RESOURCES':\n    case 'RECEIVE_RESOURCE_ERROR':\n      return receiveResponse(source, action.fetchId, action.fetchRange);\n\n    case 'REFETCH_RESOURCES':\n      return fetchSource(source, dateProfile.activeRange, calendar);\n\n    default:\n      return source;\n  }\n}\n\nvar uid$1 = 0;\n\nfunction createSource(input, calendar, forceFetch) {\n  if (input) {\n    var source = parseResourceSource(input);\n\n    if (forceFetch || !calendar.opt('refetchResourcesOnNavigate')) {\n      // because assumes handleRange will do it later\n      source = fetchSource(source, null, calendar);\n    }\n\n    return source;\n  }\n\n  return null;\n}\n\nfunction handleRange(source, activeRange, calendar) {\n  if (calendar.opt('refetchResourcesOnNavigate') && !doesSourceIgnoreRange(source) && (!source.fetchRange || !rangesEqual(source.fetchRange, activeRange))) {\n    return fetchSource(source, activeRange, calendar);\n  } else {\n    return source;\n  }\n}\n\nfunction fetchSource(source, fetchRange, calendar) {\n  var sourceDef = getResourceSourceDef(source.sourceDefId);\n  var fetchId = String(uid$1++);\n  sourceDef.fetch({\n    resourceSource: source,\n    calendar: calendar,\n    range: fetchRange\n  }, function (res) {\n    // HACK\n    // do before calling dispatch in case dispatch renders synchronously\n    calendar.afterSizingTriggers._resourcesRendered = [null]; // fire once\n\n    calendar.dispatch({\n      type: 'RECEIVE_RESOURCES',\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      rawResources: res.rawResources\n    });\n  }, function (error) {\n    calendar.dispatch({\n      type: 'RECEIVE_RESOURCE_ERROR',\n      fetchId: fetchId,\n      fetchRange: fetchRange,\n      error: error\n    });\n  });\n  return __assign({}, source, {\n    isFetching: true,\n    latestFetchId: fetchId\n  });\n}\n\nfunction receiveResponse(source, fetchId, fetchRange) {\n  if (fetchId === source.latestFetchId) {\n    return __assign({}, source, {\n      isFetching: false,\n      fetchRange: fetchRange\n    });\n  }\n\n  return source;\n}\n\nvar RESOURCE_PROPS = {\n  id: String,\n  title: String,\n  parentId: String,\n  businessHours: null,\n  children: null,\n  extendedProps: null\n};\nvar PRIVATE_ID_PREFIX = '_fc:';\nvar uid$2 = 0;\n/*\nneeds a full store so that it can populate children too\n*/\n\nfunction parseResource(input, parentId, store, calendar) {\n  if (parentId === void 0) {\n    parentId = '';\n  }\n\n  var leftovers0 = {};\n  var props = refineProps(input, RESOURCE_PROPS, {}, leftovers0);\n  var leftovers1 = {};\n  var ui = processScopedUiProps('event', leftovers0, calendar, leftovers1);\n\n  if (!props.id) {\n    props.id = PRIVATE_ID_PREFIX + uid$2++;\n  }\n\n  if (!props.parentId) {\n    // give precedence to the parentId property\n    props.parentId = parentId;\n  }\n\n  props.businessHours = props.businessHours ? parseBusinessHours(props.businessHours, calendar) : null;\n  props.ui = ui;\n  props.extendedProps = __assign({}, leftovers1, props.extendedProps); // help out ResourceApi from having user modify props\n\n  Object.freeze(ui.classNames);\n  Object.freeze(props.extendedProps);\n  if (store[props.id]) ;else {\n    store[props.id] = props;\n\n    if (props.children) {\n      for (var _i = 0, _a = props.children; _i < _a.length; _i++) {\n        var childInput = _a[_i];\n        parseResource(childInput, props.id, store, calendar);\n      }\n\n      delete props.children;\n    }\n  }\n  return props;\n}\n/*\nTODO: use this in more places\n*/\n\n\nfunction getPublicId(id) {\n  if (id.indexOf(PRIVATE_ID_PREFIX) === 0) {\n    return '';\n  }\n\n  return id;\n}\n\nfunction reduceResourceStore(store, action, source, calendar) {\n  switch (action.type) {\n    case 'INIT':\n      return {};\n\n    case 'RECEIVE_RESOURCES':\n      return receiveRawResources(store, action.rawResources, action.fetchId, source, calendar);\n\n    case 'ADD_RESOURCE':\n      return addResource(store, action.resourceHash);\n\n    case 'REMOVE_RESOURCE':\n      return removeResource(store, action.resourceId);\n\n    case 'SET_RESOURCE_PROP':\n      return setResourceProp(store, action.resourceId, action.propName, action.propValue);\n\n    case 'RESET_RESOURCES':\n      // must make the calendar think each resource is a new object :/\n      return mapHash(store, function (resource) {\n        return __assign({}, resource);\n      });\n\n    default:\n      return store;\n  }\n}\n\nfunction receiveRawResources(existingStore, inputs, fetchId, source, calendar) {\n  if (source.latestFetchId === fetchId) {\n    var nextStore = {};\n\n    for (var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++) {\n      var input = inputs_1[_i];\n      parseResource(input, '', nextStore, calendar);\n    }\n\n    return nextStore;\n  } else {\n    return existingStore;\n  }\n}\n\nfunction addResource(existingStore, additions) {\n  // TODO: warn about duplicate IDs\n  return __assign({}, existingStore, additions);\n}\n\nfunction removeResource(existingStore, resourceId) {\n  var newStore = __assign({}, existingStore);\n\n  delete newStore[resourceId]; // promote children\n\n  for (var childResourceId in newStore) {\n    // a child, *maybe* but probably not\n    if (newStore[childResourceId].parentId === resourceId) {\n      newStore[childResourceId] = __assign({}, newStore[childResourceId], {\n        parentId: ''\n      });\n    }\n  }\n\n  return newStore;\n}\n\nfunction setResourceProp(existingStore, resourceId, name, value) {\n  var _a, _b;\n\n  var existingResource = existingStore[resourceId]; // TODO: sanitization\n\n  if (existingResource) {\n    return __assign({}, existingStore, (_a = {}, _a[resourceId] = __assign({}, existingResource, (_b = {}, _b[name] = value, _b)), _a));\n  } else {\n    return existingStore;\n  }\n}\n\nfunction reduceResourceEntityExpansions(expansions, action) {\n  var _a;\n\n  switch (action.type) {\n    case 'INIT':\n      return {};\n\n    case 'SET_RESOURCE_ENTITY_EXPANDED':\n      return __assign({}, expansions, (_a = {}, _a[action.id] = action.isExpanded, _a));\n\n    default:\n      return expansions;\n  }\n}\n\nfunction resourcesReducers(state, action, calendar) {\n  var resourceSource = reduceResourceSource(state.resourceSource, action, state.dateProfile, calendar);\n  var resourceStore = reduceResourceStore(state.resourceStore, action, resourceSource, calendar);\n  var resourceEntityExpansions = reduceResourceEntityExpansions(state.resourceEntityExpansions, action);\n  return __assign({}, state, {\n    resourceSource: resourceSource,\n    resourceStore: resourceStore,\n    resourceEntityExpansions: resourceEntityExpansions\n  });\n}\n\nvar RESOURCE_RELATED_PROPS = {\n  resourceId: String,\n  resourceIds: function (items) {\n    return (items || []).map(function (item) {\n      return String(item);\n    });\n  },\n  resourceEditable: Boolean\n};\n\nfunction parseEventDef(def, props, leftovers) {\n  var resourceRelatedProps = refineProps(props, RESOURCE_RELATED_PROPS, {}, leftovers);\n  var resourceIds = resourceRelatedProps.resourceIds;\n\n  if (resourceRelatedProps.resourceId) {\n    resourceIds.push(resourceRelatedProps.resourceId);\n  }\n\n  def.resourceIds = resourceIds;\n  def.resourceEditable = resourceRelatedProps.resourceEditable;\n}\n\nfunction transformDateSelectionJoin(hit0, hit1) {\n  var resourceId0 = hit0.dateSpan.resourceId;\n  var resourceId1 = hit1.dateSpan.resourceId;\n\n  if (resourceId0 && resourceId1) {\n    if (hit0.component.allowAcrossResources === false && resourceId0 !== resourceId1) {\n      return false;\n    } else {\n      return {\n        resourceId: resourceId0\n      };\n    }\n  }\n}\n\nvar ResourceApi =\n/** @class */\nfunction () {\n  function ResourceApi(calendar, rawResource) {\n    this._calendar = calendar;\n    this._resource = rawResource;\n  }\n\n  ResourceApi.prototype.setProp = function (name, value) {\n    this._calendar.dispatch({\n      type: 'SET_RESOURCE_PROP',\n      resourceId: this._resource.id,\n      propName: name,\n      propValue: value\n    });\n  };\n\n  ResourceApi.prototype.remove = function () {\n    this._calendar.dispatch({\n      type: 'REMOVE_RESOURCE',\n      resourceId: this._resource.id\n    });\n  };\n\n  ResourceApi.prototype.getParent = function () {\n    var calendar = this._calendar;\n    var parentId = this._resource.parentId;\n\n    if (parentId) {\n      return new ResourceApi(calendar, calendar.state.resourceSource[parentId]);\n    } else {\n      return null;\n    }\n  };\n\n  ResourceApi.prototype.getChildren = function () {\n    var thisResourceId = this._resource.id;\n    var calendar = this._calendar;\n    var resourceStore = calendar.state.resourceStore;\n    var childApis = [];\n\n    for (var resourceId in resourceStore) {\n      if (resourceStore[resourceId].parentId === thisResourceId) {\n        childApis.push(new ResourceApi(calendar, resourceStore[resourceId]));\n      }\n    }\n\n    return childApis;\n  };\n  /*\n  this is really inefficient!\n  TODO: make EventApi::resourceIds a hash or keep an index in the Calendar's state\n  */\n\n\n  ResourceApi.prototype.getEvents = function () {\n    var thisResourceId = this._resource.id;\n    var calendar = this._calendar;\n    var _a = calendar.state.eventStore,\n        defs = _a.defs,\n        instances = _a.instances;\n    var eventApis = [];\n\n    for (var instanceId in instances) {\n      var instance = instances[instanceId];\n      var def = defs[instance.defId];\n\n      if (def.resourceIds.indexOf(thisResourceId) !== -1) {\n        // inefficient!!!\n        eventApis.push(new EventApi(calendar, def, instance));\n      }\n    }\n\n    return eventApis;\n  };\n\n  Object.defineProperty(ResourceApi.prototype, \"id\", {\n    get: function () {\n      return this._resource.id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"title\", {\n    get: function () {\n      return this._resource.title;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventConstraint\", {\n    get: function () {\n      return this._resource.ui.constraints[0] || null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventOverlap\", {\n    get: function () {\n      return this._resource.ui.overlap;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventAllow\", {\n    get: function () {\n      return this._resource.ui.allows[0] || null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventBackgroundColor\", {\n    get: function () {\n      return this._resource.ui.backgroundColor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventBorderColor\", {\n    get: function () {\n      return this._resource.ui.borderColor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventTextColor\", {\n    get: function () {\n      return this._resource.ui.textColor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"eventClassNames\", {\n    // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n    get: function () {\n      return this._resource.ui.classNames;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(ResourceApi.prototype, \"extendedProps\", {\n    get: function () {\n      return this._resource.extendedProps;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return ResourceApi;\n}();\n\nCalendar.prototype.addResource = function (input, scrollTo) {\n  var _a;\n\n  if (scrollTo === void 0) {\n    scrollTo = true;\n  }\n\n  var resourceHash;\n  var resource;\n\n  if (input instanceof ResourceApi) {\n    resource = input._resource;\n    resourceHash = (_a = {}, _a[resource.id] = resource, _a);\n  } else {\n    resourceHash = {};\n    resource = parseResource(input, '', resourceHash, this);\n  } // HACK\n\n\n  if (scrollTo) {\n    this.component.view.addScroll({\n      forcedRowId: resource.id\n    });\n  }\n\n  this.dispatch({\n    type: 'ADD_RESOURCE',\n    resourceHash: resourceHash\n  });\n  return new ResourceApi(this, resource);\n};\n\nCalendar.prototype.getResourceById = function (id) {\n  id = String(id);\n\n  if (this.state.resourceStore) {\n    // guard against calendar with no resource functionality\n    var rawResource = this.state.resourceStore[id];\n\n    if (rawResource) {\n      return new ResourceApi(this, rawResource);\n    }\n  }\n\n  return null;\n};\n\nCalendar.prototype.getResources = function () {\n  var resourceStore = this.state.resourceStore;\n  var resourceApis = [];\n\n  if (resourceStore) {\n    // guard against calendar with no resource functionality\n    for (var resourceId in resourceStore) {\n      resourceApis.push(new ResourceApi(this, resourceStore[resourceId]));\n    }\n  }\n\n  return resourceApis;\n};\n\nCalendar.prototype.getTopLevelResources = function () {\n  var resourceStore = this.state.resourceStore;\n  var resourceApis = [];\n\n  if (resourceStore) {\n    // guard against calendar with no resource functionality\n    for (var resourceId in resourceStore) {\n      if (!resourceStore[resourceId].parentId) {\n        resourceApis.push(new ResourceApi(this, resourceStore[resourceId]));\n      }\n    }\n  }\n\n  return resourceApis;\n};\n\nCalendar.prototype.rerenderResources = function () {\n  this.dispatch({\n    type: 'RESET_RESOURCES'\n  });\n};\n\nCalendar.prototype.refetchResources = function () {\n  this.dispatch({\n    type: 'REFETCH_RESOURCES'\n  });\n};\n\nfunction transformDatePoint(dateSpan, calendar) {\n  return dateSpan.resourceId ? {\n    resource: calendar.getResourceById(dateSpan.resourceId)\n  } : {};\n}\n\nfunction transformDateSpan(dateSpan, calendar) {\n  return dateSpan.resourceId ? {\n    resource: calendar.getResourceById(dateSpan.resourceId)\n  } : {};\n}\n/*\nsplits things BASED OFF OF which resources they are associated with.\ncreates a '' entry which is when something has NO resource.\n*/\n\n\nvar ResourceSplitter =\n/** @class */\nfunction (_super) {\n  __extends(ResourceSplitter, _super);\n\n  function ResourceSplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ResourceSplitter.prototype.getKeyInfo = function (props) {\n    return __assign({\n      '': {}\n    }, props.resourceStore // already has `ui` and `businessHours` keys!\n    );\n  };\n\n  ResourceSplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    return [dateSpan.resourceId || ''];\n  };\n\n  ResourceSplitter.prototype.getKeysForEventDef = function (eventDef) {\n    var resourceIds = eventDef.resourceIds;\n\n    if (!resourceIds.length) {\n      return [''];\n    }\n\n    return resourceIds;\n  };\n\n  return ResourceSplitter;\n}(Splitter);\n\nfunction isPropsValidWithResources(props, calendar) {\n  var splitter = new ResourceSplitter();\n  var sets = splitter.splitProps(__assign({}, props, {\n    resourceStore: calendar.state.resourceStore\n  }));\n\n  for (var resourceId in sets) {\n    var props_1 = sets[resourceId]; // merge in event data from the non-resource segment\n\n    if (resourceId && sets['']) {\n      // current segment is not the non-resource one, and there IS a non-resource one\n      props_1 = __assign({}, props_1, {\n        eventStore: mergeEventStores(sets[''].eventStore, props_1.eventStore),\n        eventUiBases: __assign({}, sets[''].eventUiBases, props_1.eventUiBases)\n      });\n    }\n\n    if (!isPropsValid(props_1, calendar, {\n      resourceId: resourceId\n    }, filterConfig.bind(null, resourceId))) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction filterConfig(resourceId, config) {\n  return __assign({}, config, {\n    constraints: filterConstraints(resourceId, config.constraints)\n  });\n}\n\nfunction filterConstraints(resourceId, constraints) {\n  return constraints.map(function (constraint) {\n    var defs = constraint.defs;\n\n    if (defs) {\n      // we are dealing with an EventStore\n      // if any of the events define constraints to resources that are NOT this resource,\n      // then this resource is unconditionally prohibited, which is what a `false` value does.\n      for (var defId in defs) {\n        var resourceIds = defs[defId].resourceIds;\n\n        if (resourceIds.length && resourceIds.indexOf(resourceId) === -1) {\n          // TODO: use a hash?!!! (for other reasons too)\n          return false;\n        }\n      }\n    }\n\n    return constraint;\n  });\n}\n\nfunction transformExternalDef(dateSpan) {\n  return dateSpan.resourceId ? {\n    resourceId: dateSpan.resourceId\n  } : {};\n}\n\nfunction transformEventResizeJoin(hit0, hit1) {\n  var component = hit0.component;\n\n  if (component.allowAcrossResources === false && hit0.dateSpan.resourceId !== hit1.dateSpan.resourceId) {\n    return false;\n  }\n}\n\nEventApi.prototype.getResources = function () {\n  var calendar = this._calendar;\n  return this._def.resourceIds.map(function (resourceId) {\n    return calendar.getResourceById(resourceId);\n  });\n};\n\nEventApi.prototype.setResources = function (resources) {\n  var resourceIds = []; // massage resources -> resourceIds\n\n  for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {\n    var resource = resources_1[_i];\n    var resourceId = null;\n\n    if (typeof resource === 'string') {\n      resourceId = resource;\n    } else if (typeof resource === 'number') {\n      resourceId = String(resource);\n    } else if (resource instanceof ResourceApi) {\n      resourceId = resource.id; // guaranteed to always have an ID. hmmm\n    } else {\n      console.warn('unknown resource type: ' + resource);\n    }\n\n    if (resourceId) {\n      resourceIds.push(resourceId);\n    }\n  }\n\n  this.mutate({\n    standardProps: {\n      resourceIds: resourceIds\n    }\n  });\n};\n\nvar RELEASE_DATE = '2019-08-10'; // for Scheduler\n\nvar UPGRADE_WINDOW = 365 + 7; // days. 1 week leeway, for tz shift reasons too\n\nvar LICENSE_INFO_URL = 'http://fullcalendar.io/scheduler/license/';\nvar PRESET_LICENSE_KEYS = ['GPL-My-Project-Is-Open-Source', 'CC-Attribution-NonCommercial-NoDerivatives'];\nvar CSS = {\n  position: 'absolute',\n  'z-index': 99999,\n  bottom: '1px',\n  left: '1px',\n  background: '#eee',\n  'border-color': '#ddd',\n  'border-style': 'solid',\n  'border-width': '1px 1px 0 0',\n  padding: '2px 4px',\n  'font-size': '12px',\n  'border-top-right-radius': '3px'\n};\n\nfunction injectLicenseWarning(containerEl, calendar) {\n  var key = calendar.opt('schedulerLicenseKey');\n\n  if (!isImmuneUrl(window.location.href) && !isValidKey(key)) {\n    appendToElement(containerEl, '<div class=\"fc-license-message\" style=\"' + htmlEscape(cssToStr(CSS)) + '\">' + 'Please use a valid license key. <a href=\"' + LICENSE_INFO_URL + '\">More Info</a>' + '</div>');\n  }\n}\n/*\nThis decryption is not meant to be bulletproof. Just a way to remind about an upgrade.\n*/\n\n\nfunction isValidKey(key) {\n  if (PRESET_LICENSE_KEYS.indexOf(key) !== -1) {\n    return true;\n  }\n\n  var parts = (key || '').match(/^(\\d+)\\-fcs\\-(\\d+)$/);\n\n  if (parts && parts[1].length === 10) {\n    var purchaseDate = new Date(parseInt(parts[2], 10) * 1000);\n    var releaseDate = new Date(config.mockSchedulerReleaseDate || RELEASE_DATE);\n\n    if (isValidDate(releaseDate)) {\n      // token won't be replaced in dev mode\n      var minPurchaseDate = addDays(releaseDate, -UPGRADE_WINDOW);\n\n      if (minPurchaseDate < purchaseDate) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction isImmuneUrl(url) {\n  return /\\w+\\:\\/\\/fullcalendar\\.io\\/|\\/examples\\/[\\w-]+\\.html$/.test(url);\n}\n\nvar optionChangeHandlers = {\n  resources: handleResources\n};\n\nfunction handleResources(newSourceInput, calendar, deepEqual) {\n  var oldSourceInput = calendar.state.resourceSource._raw;\n\n  if (!deepEqual(oldSourceInput, newSourceInput)) {\n    calendar.dispatch({\n      type: 'RESET_RESOURCE_SOURCE',\n      resourceSourceInput: newSourceInput\n    });\n  }\n}\n\nregisterResourceSourceDef({\n  ignoreRange: true,\n  parseMeta: function (raw) {\n    if (Array.isArray(raw)) {\n      return raw;\n    } else if (Array.isArray(raw.resources)) {\n      return raw.resources;\n    }\n\n    return null;\n  },\n  fetch: function (arg, successCallback) {\n    successCallback({\n      rawResources: arg.resourceSource.meta\n    });\n  }\n});\nregisterResourceSourceDef({\n  parseMeta: function (raw) {\n    if (typeof raw === 'function') {\n      return raw;\n    } else if (typeof raw.resources === 'function') {\n      return raw.resources;\n    }\n\n    return null;\n  },\n  fetch: function (arg, success, failure) {\n    var dateEnv = arg.calendar.dateEnv;\n    var func = arg.resourceSource.meta;\n    var publicArg = {};\n\n    if (arg.range) {\n      publicArg = {\n        start: dateEnv.toDate(arg.range.start),\n        end: dateEnv.toDate(arg.range.end),\n        startStr: dateEnv.formatIso(arg.range.start),\n        endStr: dateEnv.formatIso(arg.range.end),\n        timeZone: dateEnv.timeZone\n      };\n    } // TODO: make more dry with EventSourceFunc\n    // TODO: accept a response?\n\n\n    unpromisify(func.bind(null, publicArg), function (rawResources) {\n      success({\n        rawResources: rawResources\n      }); // needs an object response\n    }, failure // send errorObj directly to failure callback\n    );\n  }\n});\nregisterResourceSourceDef({\n  parseMeta: function (raw) {\n    if (typeof raw === 'string') {\n      raw = {\n        url: raw\n      };\n    } else if (!raw || typeof raw !== 'object' || !raw.url) {\n      return null;\n    }\n\n    return {\n      url: raw.url,\n      method: (raw.method || 'GET').toUpperCase(),\n      extraParams: raw.extraParams\n    };\n  },\n  fetch: function (arg, successCallback, failureCallback) {\n    var meta = arg.resourceSource.meta;\n    var requestParams = buildRequestParams(meta, arg.range, arg.calendar);\n    requestJson(meta.method, meta.url, requestParams, function (rawResources, xhr) {\n      successCallback({\n        rawResources: rawResources,\n        xhr: xhr\n      });\n    }, function (message, xhr) {\n      failureCallback({\n        message: message,\n        xhr: xhr\n      });\n    });\n  }\n}); // TODO: somehow consolidate with event json feed\n\nfunction buildRequestParams(meta, range, calendar) {\n  var dateEnv = calendar.dateEnv;\n  var startParam;\n  var endParam;\n  var timeZoneParam;\n  var customRequestParams;\n  var params = {};\n\n  if (range) {\n    // startParam = meta.startParam\n    // if (startParam == null) {\n    startParam = calendar.opt('startParam'); // }\n    // endParam = meta.endParam\n    // if (endParam == null) {\n\n    endParam = calendar.opt('endParam'); // }\n    // timeZoneParam = meta.timeZoneParam\n    // if (timeZoneParam == null) {\n\n    timeZoneParam = calendar.opt('timeZoneParam'); // }\n\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n\n    if (dateEnv.timeZone !== 'local') {\n      params[timeZoneParam] = dateEnv.timeZone;\n    }\n  } // retrieve any outbound GET/POST data from the options\n\n\n  if (typeof meta.extraParams === 'function') {\n    // supplied as a function that returns a key/value object\n    customRequestParams = meta.extraParams();\n  } else {\n    // probably supplied as a straight key/value object\n    customRequestParams = meta.extraParams || {};\n  }\n\n  __assign(params, customRequestParams);\n\n  return params;\n}\n\nfunction buildResourceTextFunc(resourceTextSetting, calendar) {\n  if (typeof resourceTextSetting === 'function') {\n    return function (resource) {\n      return resourceTextSetting(new ResourceApi(calendar, resource));\n    };\n  } else {\n    return function (resource) {\n      return resource.title || getPublicId(resource.id);\n    };\n  }\n}\n\nvar ResourceDayHeader =\n/** @class */\nfunction (_super) {\n  __extends(ResourceDayHeader, _super);\n\n  function ResourceDayHeader(context, parentEl) {\n    var _this = _super.call(this, context) || this;\n\n    _this.datesAboveResources = _this.opt('datesAboveResources');\n    _this.resourceTextFunc = buildResourceTextFunc(_this.opt('resourceText'), _this.calendar);\n    parentEl.innerHTML = ''; // because might be nbsp\n\n    parentEl.appendChild(_this.el = htmlToElement('<div class=\"fc-row ' + _this.theme.getClass('headerRow') + '\">' + '<table class=\"' + _this.theme.getClass('tableGrid') + '\">' + '<thead></thead>' + '</table>' + '</div>'));\n    _this.thead = _this.el.querySelector('thead');\n    return _this;\n  }\n\n  ResourceDayHeader.prototype.destroy = function () {\n    removeElement(this.el);\n  };\n\n  ResourceDayHeader.prototype.render = function (props) {\n    var html;\n    this.dateFormat = createFormatter(this.opt('columnHeaderFormat') || computeFallbackHeaderFormat(props.datesRepDistinctDays, props.dates.length));\n\n    if (props.dates.length === 1) {\n      html = this.renderResourceRow(props.resources);\n    } else {\n      if (this.datesAboveResources) {\n        html = this.renderDayAndResourceRows(props.dates, props.resources);\n      } else {\n        html = this.renderResourceAndDayRows(props.resources, props.dates);\n      }\n    }\n\n    this.thead.innerHTML = html;\n    this.processResourceEls(props.resources);\n  };\n\n  ResourceDayHeader.prototype.renderResourceRow = function (resources) {\n    var _this = this;\n\n    var cellHtmls = resources.map(function (resource) {\n      return _this.renderResourceCell(resource, 1);\n    });\n    return this.buildTr(cellHtmls);\n  };\n\n  ResourceDayHeader.prototype.renderDayAndResourceRows = function (dates, resources) {\n    var dateHtmls = [];\n    var resourceHtmls = [];\n\n    for (var _i = 0, dates_1 = dates; _i < dates_1.length; _i++) {\n      var date = dates_1[_i];\n      dateHtmls.push(this.renderDateCell(date, resources.length));\n\n      for (var _a = 0, resources_1 = resources; _a < resources_1.length; _a++) {\n        var resource = resources_1[_a];\n        resourceHtmls.push(this.renderResourceCell(resource, 1, date));\n      }\n    }\n\n    return this.buildTr(dateHtmls) + this.buildTr(resourceHtmls);\n  };\n\n  ResourceDayHeader.prototype.renderResourceAndDayRows = function (resources, dates) {\n    var resourceHtmls = [];\n    var dateHtmls = [];\n\n    for (var _i = 0, resources_2 = resources; _i < resources_2.length; _i++) {\n      var resource = resources_2[_i];\n      resourceHtmls.push(this.renderResourceCell(resource, dates.length));\n\n      for (var _a = 0, dates_2 = dates; _a < dates_2.length; _a++) {\n        var date = dates_2[_a];\n        dateHtmls.push(this.renderDateCell(date, 1, resource));\n      }\n    }\n\n    return this.buildTr(resourceHtmls) + this.buildTr(dateHtmls);\n  }; // Cell Rendering Utils\n  // ----------------------------------------------------------------------------------------------\n  // a cell with the resource name. might be associated with a specific day\n\n\n  ResourceDayHeader.prototype.renderResourceCell = function (resource, colspan, date) {\n    var dateEnv = this.dateEnv;\n    return '<th class=\"fc-resource-cell\"' + ' data-resource-id=\"' + resource.id + '\"' + (date ? ' data-date=\"' + dateEnv.formatIso(date, {\n      omitTime: true\n    }) + '\"' : '') + (colspan > 1 ? ' colspan=\"' + colspan + '\"' : '') + '>' + htmlEscape(this.resourceTextFunc(resource)) + '</th>';\n  }; // a cell with date text. might have a resource associated with it\n\n\n  ResourceDayHeader.prototype.renderDateCell = function (date, colspan, resource) {\n    var props = this.props;\n    return renderDateCell(date, props.dateProfile, props.datesRepDistinctDays, props.dates.length * props.resources.length, this.dateFormat, this.context, colspan, resource ? 'data-resource-id=\"' + resource.id + '\"' : '');\n  };\n\n  ResourceDayHeader.prototype.buildTr = function (cellHtmls) {\n    if (!cellHtmls.length) {\n      cellHtmls = ['<td>&nbsp;</td>'];\n    }\n\n    if (this.props.renderIntroHtml) {\n      cellHtmls = [this.props.renderIntroHtml()].concat(cellHtmls);\n    }\n\n    if (this.isRtl) {\n      cellHtmls.reverse();\n    }\n\n    return '<tr>' + cellHtmls.join('') + '</tr>';\n  }; // Post-rendering\n  // ----------------------------------------------------------------------------------------------\n  // given a container with already rendered resource cells\n\n\n  ResourceDayHeader.prototype.processResourceEls = function (resources) {\n    var _this = this;\n\n    var view = this.view;\n    findElements(this.thead, '.fc-resource-cell').forEach(function (node, col) {\n      col = col % resources.length;\n\n      if (_this.isRtl) {\n        col = resources.length - 1 - col;\n      }\n\n      var resource = resources[col];\n      view.publiclyTrigger('resourceRender', [{\n        resource: new ResourceApi(_this.calendar, resource),\n        el: node,\n        view: view\n      }]);\n    });\n  };\n\n  return ResourceDayHeader;\n}(Component);\n\nvar AbstractResourceDayTable =\n/** @class */\nfunction () {\n  function AbstractResourceDayTable(dayTable, resources) {\n    this.dayTable = dayTable;\n    this.resources = resources;\n    this.resourceIndex = new ResourceIndex(resources);\n    this.rowCnt = dayTable.rowCnt;\n    this.colCnt = dayTable.colCnt * resources.length;\n    this.cells = this.buildCells();\n  }\n\n  AbstractResourceDayTable.prototype.buildCells = function () {\n    var _a = this,\n        rowCnt = _a.rowCnt,\n        dayTable = _a.dayTable,\n        resources = _a.resources;\n\n    var rows = [];\n\n    for (var row = 0; row < rowCnt; row++) {\n      var rowCells = [];\n\n      for (var dateCol = 0; dateCol < dayTable.colCnt; dateCol++) {\n        for (var resourceCol = 0; resourceCol < resources.length; resourceCol++) {\n          var resource = resources[resourceCol];\n          var htmlAttrs = 'data-resource-id=\"' + resource.id + '\"';\n          rowCells[this.computeCol(dateCol, resourceCol)] = {\n            date: dayTable.cells[row][dateCol].date,\n            resource: resource,\n            htmlAttrs: htmlAttrs\n          };\n        }\n      }\n\n      rows.push(rowCells);\n    }\n\n    return rows;\n  };\n\n  return AbstractResourceDayTable;\n}();\n/*\nresources over dates\n*/\n\n\nvar ResourceDayTable =\n/** @class */\nfunction (_super) {\n  __extends(ResourceDayTable, _super);\n\n  function ResourceDayTable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  ResourceDayTable.prototype.computeCol = function (dateI, resourceI) {\n    return resourceI * this.dayTable.colCnt + dateI;\n  };\n  /*\n  all date ranges are intact\n  */\n\n\n  ResourceDayTable.prototype.computeColRanges = function (dateStartI, dateEndI, resourceI) {\n    return [{\n      firstCol: this.computeCol(dateStartI, resourceI),\n      lastCol: this.computeCol(dateEndI, resourceI),\n      isStart: true,\n      isEnd: true\n    }];\n  };\n\n  return ResourceDayTable;\n}(AbstractResourceDayTable);\n/*\ndates over resources\n*/\n\n\nvar DayResourceTable =\n/** @class */\nfunction (_super) {\n  __extends(DayResourceTable, _super);\n\n  function DayResourceTable() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DayResourceTable.prototype.computeCol = function (dateI, resourceI) {\n    return dateI * this.resources.length + resourceI;\n  };\n  /*\n  every single day is broken up\n  */\n\n\n  DayResourceTable.prototype.computeColRanges = function (dateStartI, dateEndI, resourceI) {\n    var segs = [];\n\n    for (var i = dateStartI; i <= dateEndI; i++) {\n      var col = this.computeCol(i, resourceI);\n      segs.push({\n        firstCol: col,\n        lastCol: col,\n        isStart: i === dateStartI,\n        isEnd: i === dateEndI\n      });\n    }\n\n    return segs;\n  };\n\n  return DayResourceTable;\n}(AbstractResourceDayTable);\n\nvar ResourceIndex =\n/** @class */\nfunction () {\n  function ResourceIndex(resources) {\n    var indicesById = {};\n    var ids = [];\n\n    for (var i = 0; i < resources.length; i++) {\n      var id = resources[i].id;\n      ids.push(id);\n      indicesById[id] = i;\n    }\n\n    this.ids = ids;\n    this.indicesById = indicesById;\n    this.length = resources.length;\n  }\n\n  return ResourceIndex;\n}();\n/*\nTODO: just use ResourceHash somehow? could then use the generic ResourceSplitter\n*/\n\n\nvar VResourceSplitter =\n/** @class */\nfunction (_super) {\n  __extends(VResourceSplitter, _super);\n\n  function VResourceSplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  VResourceSplitter.prototype.getKeyInfo = function (props) {\n    var resourceDayTable = props.resourceDayTable;\n    var hash = mapHash(resourceDayTable.resourceIndex.indicesById, function (i) {\n      return resourceDayTable.resources[i]; // has `ui` AND `businessHours` keys!\n    }); // :(\n\n    hash[''] = {};\n    return hash;\n  };\n\n  VResourceSplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    return [dateSpan.resourceId || ''];\n  };\n\n  VResourceSplitter.prototype.getKeysForEventDef = function (eventDef) {\n    var resourceIds = eventDef.resourceIds;\n\n    if (!resourceIds.length) {\n      return [''];\n    }\n\n    return resourceIds;\n  };\n\n  return VResourceSplitter;\n}(Splitter); // joiner\n\n\nvar NO_SEGS = []; // for memoizing\n\nvar VResourceJoiner =\n/** @class */\nfunction () {\n  function VResourceJoiner() {\n    this.joinDateSelection = memoize(this.joinSegs);\n    this.joinBusinessHours = memoize(this.joinSegs);\n    this.joinFgEvents = memoize(this.joinSegs);\n    this.joinBgEvents = memoize(this.joinSegs);\n    this.joinEventDrags = memoize(this.joinInteractions);\n    this.joinEventResizes = memoize(this.joinInteractions);\n  }\n  /*\n  propSets also has a '' key for things with no resource\n  */\n\n\n  VResourceJoiner.prototype.joinProps = function (propSets, resourceDayTable) {\n    var dateSelectionSets = [];\n    var businessHoursSets = [];\n    var fgEventSets = [];\n    var bgEventSets = [];\n    var eventDrags = [];\n    var eventResizes = [];\n    var eventSelection = '';\n    var keys = resourceDayTable.resourceIndex.ids.concat(['']); // add in the all-resource key\n\n    for (var _i = 0, keys_1 = keys; _i < keys_1.length; _i++) {\n      var key = keys_1[_i];\n      var props = propSets[key];\n      dateSelectionSets.push(props.dateSelectionSegs);\n      businessHoursSets.push(key ? props.businessHourSegs : NO_SEGS); // don't include redundant all-resource businesshours\n\n      fgEventSets.push(key ? props.fgEventSegs : NO_SEGS); // don't include fg all-resource segs\n\n      bgEventSets.push(props.bgEventSegs);\n      eventDrags.push(props.eventDrag);\n      eventResizes.push(props.eventResize);\n      eventSelection = eventSelection || props.eventSelection;\n    }\n\n    return {\n      dateSelectionSegs: this.joinDateSelection.apply(this, [resourceDayTable].concat(dateSelectionSets)),\n      businessHourSegs: this.joinBusinessHours.apply(this, [resourceDayTable].concat(businessHoursSets)),\n      fgEventSegs: this.joinFgEvents.apply(this, [resourceDayTable].concat(fgEventSets)),\n      bgEventSegs: this.joinBgEvents.apply(this, [resourceDayTable].concat(bgEventSets)),\n      eventDrag: this.joinEventDrags.apply(this, [resourceDayTable].concat(eventDrags)),\n      eventResize: this.joinEventResizes.apply(this, [resourceDayTable].concat(eventResizes)),\n      eventSelection: eventSelection\n    };\n  };\n\n  VResourceJoiner.prototype.joinSegs = function (resourceDayTable) {\n    var segGroups = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      segGroups[_i - 1] = arguments[_i];\n    }\n\n    var resourceCnt = resourceDayTable.resources.length;\n    var transformedSegs = [];\n\n    for (var i = 0; i < resourceCnt; i++) {\n      for (var _a = 0, _b = segGroups[i]; _a < _b.length; _a++) {\n        var seg = _b[_a];\n        transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));\n      }\n\n      for (var _c = 0, _d = segGroups[resourceCnt]; _c < _d.length; _c++) {\n        // one beyond. the all-resource\n        var seg = _d[_c];\n        transformedSegs.push.apply( // one beyond. the all-resource\n        transformedSegs, this.transformSeg(seg, resourceDayTable, i));\n      }\n    }\n\n    return transformedSegs;\n  };\n  /*\n  for expanding non-resource segs to all resources.\n  only for public use.\n  no memoizing.\n  */\n\n\n  VResourceJoiner.prototype.expandSegs = function (resourceDayTable, segs) {\n    var resourceCnt = resourceDayTable.resources.length;\n    var transformedSegs = [];\n\n    for (var i = 0; i < resourceCnt; i++) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i));\n      }\n    }\n\n    return transformedSegs;\n  };\n\n  VResourceJoiner.prototype.joinInteractions = function (resourceDayTable) {\n    var interactions = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      interactions[_i - 1] = arguments[_i];\n    }\n\n    var resourceCnt = resourceDayTable.resources.length;\n    var affectedInstances = {};\n    var transformedSegs = [];\n    var isEvent = false;\n    var sourceSeg = null;\n\n    for (var i = 0; i < resourceCnt; i++) {\n      var interaction = interactions[i];\n\n      if (interaction) {\n        for (var _a = 0, _b = interaction.segs; _a < _b.length; _a++) {\n          var seg = _b[_a];\n          transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i) // TODO: templateify Interaction::segs\n          );\n        }\n\n        __assign(affectedInstances, interaction.affectedInstances);\n\n        isEvent = isEvent || interaction.isEvent;\n        sourceSeg = sourceSeg || interaction.sourceSeg;\n      }\n\n      if (interactions[resourceCnt]) {\n        // one beyond. the all-resource\n        for (var _c = 0, _d = interactions[resourceCnt].segs; _c < _d.length; _c++) {\n          var seg = _d[_c];\n          transformedSegs.push.apply(transformedSegs, this.transformSeg(seg, resourceDayTable, i) // TODO: templateify Interaction::segs\n          );\n        }\n      }\n    }\n\n    return {\n      affectedInstances: affectedInstances,\n      segs: transformedSegs,\n      isEvent: isEvent,\n      sourceSeg: sourceSeg\n    };\n  };\n\n  return VResourceJoiner;\n}();\n/*\ndoesn't accept grouping\n*/\n\n\nfunction flattenResources(resourceStore, orderSpecs) {\n  return buildRowNodes(resourceStore, [], orderSpecs, false, {}, true).map(function (node) {\n    return node.resource;\n  });\n}\n\nfunction buildRowNodes(resourceStore, groupSpecs, orderSpecs, isVGrouping, expansions, expansionDefault) {\n  var complexNodes = buildHierarchy(resourceStore, isVGrouping ? -1 : 1, groupSpecs, orderSpecs);\n  var flatNodes = [];\n  flattenNodes(complexNodes, flatNodes, isVGrouping, [], 0, expansions, expansionDefault);\n  return flatNodes;\n}\n\nfunction flattenNodes(complexNodes, res, isVGrouping, rowSpans, depth, expansions, expansionDefault) {\n  for (var i = 0; i < complexNodes.length; i++) {\n    var complexNode = complexNodes[i];\n    var group = complexNode.group;\n\n    if (group) {\n      if (isVGrouping) {\n        var firstRowIndex = res.length;\n        var rowSpanIndex = rowSpans.length;\n        flattenNodes(complexNode.children, res, isVGrouping, rowSpans.concat(0), depth, expansions, expansionDefault);\n\n        if (firstRowIndex < res.length) {\n          var firstRow = res[firstRowIndex];\n          var firstRowSpans = firstRow.rowSpans = firstRow.rowSpans.slice();\n          firstRowSpans[rowSpanIndex] = res.length - firstRowIndex;\n        }\n      } else {\n        var id = group.spec.field + ':' + group.value;\n        var isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;\n        res.push({\n          id: id,\n          group: group,\n          isExpanded: isExpanded\n        });\n\n        if (isExpanded) {\n          flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);\n        }\n      }\n    } else if (complexNode.resource) {\n      var id = complexNode.resource.id;\n      var isExpanded = expansions[id] != null ? expansions[id] : expansionDefault;\n      res.push({\n        id: id,\n        rowSpans: rowSpans,\n        depth: depth,\n        isExpanded: isExpanded,\n        hasChildren: Boolean(complexNode.children.length),\n        resource: complexNode.resource,\n        resourceFields: complexNode.resourceFields\n      });\n\n      if (isExpanded) {\n        flattenNodes(complexNode.children, res, isVGrouping, rowSpans, depth + 1, expansions, expansionDefault);\n      }\n    }\n  }\n}\n\nfunction buildHierarchy(resourceStore, maxDepth, groupSpecs, orderSpecs) {\n  var resourceNodes = buildResourceNodes(resourceStore, orderSpecs);\n  var builtNodes = [];\n\n  for (var resourceId in resourceNodes) {\n    var resourceNode = resourceNodes[resourceId];\n\n    if (!resourceNode.resource.parentId) {\n      insertResourceNode(resourceNode, builtNodes, groupSpecs, 0, maxDepth, orderSpecs);\n    }\n  }\n\n  return builtNodes;\n}\n\nfunction buildResourceNodes(resourceStore, orderSpecs) {\n  var nodeHash = {};\n\n  for (var resourceId in resourceStore) {\n    var resource = resourceStore[resourceId];\n    nodeHash[resourceId] = {\n      resource: resource,\n      resourceFields: buildResourceFields(resource),\n      children: []\n    };\n  }\n\n  for (var resourceId in resourceStore) {\n    var resource = resourceStore[resourceId];\n\n    if (resource.parentId) {\n      var parentNode = nodeHash[resource.parentId];\n\n      if (parentNode) {\n        insertResourceNodeInSiblings(nodeHash[resourceId], parentNode.children, orderSpecs);\n      }\n    }\n  }\n\n  return nodeHash;\n}\n\nfunction insertResourceNode(resourceNode, nodes, groupSpecs, depth, maxDepth, orderSpecs) {\n  if (groupSpecs.length && (maxDepth === -1 || depth <= maxDepth)) {\n    var groupNode = ensureGroupNodes(resourceNode, nodes, groupSpecs[0]);\n    insertResourceNode(resourceNode, groupNode.children, groupSpecs.slice(1), depth + 1, maxDepth, orderSpecs);\n  } else {\n    insertResourceNodeInSiblings(resourceNode, nodes, orderSpecs);\n  }\n}\n\nfunction ensureGroupNodes(resourceNode, nodes, groupSpec) {\n  var groupValue = resourceNode.resourceFields[groupSpec.field];\n  var groupNode;\n  var newGroupIndex; // find an existing group that matches, or determine the position for a new group\n\n  if (groupSpec.order) {\n    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex++) {\n      var node = nodes[newGroupIndex];\n\n      if (node.group) {\n        var cmp = flexibleCompare(groupValue, node.group.value) * groupSpec.order;\n\n        if (cmp === 0) {\n          groupNode = node;\n          break;\n        } else if (cmp < 0) {\n          break;\n        }\n      }\n    }\n  } else {\n    // the groups are unordered\n    for (newGroupIndex = 0; newGroupIndex < nodes.length; newGroupIndex++) {\n      var node = nodes[newGroupIndex];\n\n      if (node.group && groupValue === node.group.value) {\n        groupNode = node;\n        break;\n      }\n    }\n  }\n\n  if (!groupNode) {\n    groupNode = {\n      group: {\n        value: groupValue,\n        spec: groupSpec\n      },\n      children: []\n    };\n    nodes.splice(newGroupIndex, 0, groupNode);\n  }\n\n  return groupNode;\n}\n\nfunction insertResourceNodeInSiblings(resourceNode, siblings, orderSpecs) {\n  var i;\n\n  for (i = 0; i < siblings.length; i++) {\n    var cmp = compareByFieldSpecs(siblings[i].resourceFields, resourceNode.resourceFields, orderSpecs);\n\n    if (cmp > 0) {\n      // went 1 past. insert at i\n      break;\n    }\n  }\n\n  siblings.splice(i, 0, resourceNode);\n}\n\nfunction buildResourceFields(resource) {\n  var obj = __assign({}, resource.extendedProps, resource.ui, resource);\n\n  delete obj.ui;\n  delete obj.extendedProps;\n  return obj;\n}\n\nfunction isGroupsEqual(group0, group1) {\n  return group0.spec === group1.spec && group0.value === group1.value;\n}\n\nvar main = createPlugin({\n  reducers: [resourcesReducers],\n  eventDefParsers: [parseEventDef],\n  isDraggableTransformers: [transformIsDraggable],\n  eventDragMutationMassagers: [massageEventDragMutation],\n  eventDefMutationAppliers: [applyEventDefMutation],\n  dateSelectionTransformers: [transformDateSelectionJoin],\n  datePointTransforms: [transformDatePoint],\n  dateSpanTransforms: [transformDateSpan],\n  viewPropsTransformers: [ResourceDataAdder, ResourceEventConfigAdder],\n  isPropsValid: isPropsValidWithResources,\n  externalDefTransforms: [transformExternalDef],\n  eventResizeJoinTransforms: [transformEventResizeJoin],\n  viewContainerModifiers: [injectLicenseWarning],\n  eventDropTransformers: [transformEventDrop],\n  optionChangeHandlers: optionChangeHandlers\n});\nexport default main;\nexport { AbstractResourceDayTable, DayResourceTable, ResourceApi, ResourceDayHeader, ResourceDayTable, ResourceSplitter, VResourceJoiner, VResourceSplitter, buildResourceFields, buildResourceTextFunc, buildRowNodes, flattenResources, isGroupsEqual };","map":null,"metadata":{},"sourceType":"module"}