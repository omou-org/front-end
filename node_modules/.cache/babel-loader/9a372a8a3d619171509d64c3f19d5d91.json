{"ast":null,"code":"import * as types from \"./actionTypes\";\nimport axios from \"axios\";\nconst instance = axios.create({\n  \"baseURL\": \"http://localhost:8000\"\n});\nexport const REQUEST_ALL = -1;\nexport const REQUEST_STARTED = 1;\nexport const REQUEST_SUCCESS = 2;\nexport const REQUEST_FAILED = 3;\nexport const wrapGet = (endpoint, [startType, successType, failType], id) => async (dispatch, getState) => {\n  // creates a new action based on the response given\n  const newAction = (type, response) => {\n    dispatch({\n      type,\n      \"payload\": {\n        \"id\": id || REQUEST_ALL,\n        response\n      }\n    });\n  }; // request starting\n\n\n  newAction(startType, {});\n  const requestURL = id ? \"\".concat(endpoint).concat(id, \"/\") : endpoint;\n\n  try {\n    const response = await instance.get(requestURL, {\n      \"headers\": {\n        \"Authorization\": \"Token \".concat(getState().auth.token)\n      }\n    }); // succesful request\n\n    newAction(successType, response);\n  } catch (_ref) {\n    let response = _ref.response;\n    // failed request\n    newAction(failType, response);\n  }\n};\nexport const wrapPost = (endpoint, [startType, successType, failType], data) => async (dispatch, getState) => {\n  // creates a new action based on the response given\n  const newAction = (type, response) => {\n    dispatch({\n      type,\n      \"payload\": {\n        response\n      }\n    });\n  }; // request starting\n\n\n  newAction(startType, {});\n\n  try {\n    const response = await instance.post(endpoint, data, {\n      \"headers\": {\n        \"Authorization\": \"Token \".concat(getState().auth.token)\n      }\n    }); // succesful request\n\n    newAction(successType, response);\n  } catch (_ref2) {\n    let response = _ref2.response;\n    // failed request\n    newAction(failType, response);\n  }\n};\nexport const wrapPatch = (endpoint, [startType, successType, failType], id, data) => async (dispatch, getState) => {\n  // creates a new action based on the response given\n  const newAction = (type, response) => {\n    dispatch({\n      type,\n      \"payload\": {\n        id,\n        response\n      }\n    });\n  }; // request starting\n\n\n  newAction(startType, {});\n\n  try {\n    const response = await instance.patch(\"\".concat(endpoint).concat(id, \"/\"), data, {\n      \"headers\": {\n        \"Authorization\": \"Token \".concat(getState().auth.token)\n      }\n    }); // succesful request\n\n    newAction(successType, response);\n  } catch (_ref3) {\n    let response = _ref3.response;\n    // failed request\n    newAction(failType, response);\n  }\n};\nexport const fetchCourses = id => wrapGet(\"/courses/catalog/\", [types.FETCH_COURSE_STARTED, types.FETCH_COURSE_SUCCESSFUL, types.FETCH_COURSE_FAILED], id);\nexport const fetchInstructors = id => wrapGet(\"/account/instructor/\", [types.FETCH_INSTRUCTOR_STARTED, types.FETCH_INSTRUCTOR_SUCCESSFUL, types.FETCH_INSTRUCTOR_FAILED], id);","map":{"version":3,"sources":["/Users/4e65696c/Documents/GitHub/front-end/omou-frontend/src/actions/apiActions.js"],"names":["types","axios","instance","create","REQUEST_ALL","REQUEST_STARTED","REQUEST_SUCCESS","REQUEST_FAILED","wrapGet","endpoint","startType","successType","failType","id","dispatch","getState","newAction","type","response","requestURL","get","auth","token","wrapPost","data","post","wrapPatch","patch","fetchCourses","FETCH_COURSE_STARTED","FETCH_COURSE_SUCCESSFUL","FETCH_COURSE_FAILED","fetchInstructors","FETCH_INSTRUCTOR_STARTED","FETCH_INSTRUCTOR_SUCCESSFUL","FETCH_INSTRUCTOR_FAILED"],"mappings":"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","sourcesContent":["import * as types from \"./actionTypes\";\n\nimport axios from \"axios\";\n\nconst instance = axios.create({\n    \"baseURL\": \"http://localhost:8000\",\n});\n\nexport const REQUEST_ALL = -1;\n\nexport const REQUEST_STARTED = 1;\nexport const REQUEST_SUCCESS = 2;\nexport const REQUEST_FAILED = 3;\n\nexport const wrapGet = (endpoint, [startType, successType, failType], id) =>\n    async (dispatch, getState) => {\n        // creates a new action based on the response given\n        const newAction = (type, response) => {\n            dispatch({\n                type,\n                \"payload\": {\n                    \"id\": id || REQUEST_ALL,\n                    response,\n                },\n            });\n        };\n\n        // request starting\n        newAction(startType, {});\n\n        const requestURL = id ? `${endpoint}${id}/` : endpoint;\n\n        try {\n            const response = await instance.get(requestURL, {\n                \"headers\": {\n                    \"Authorization\": `Token ${getState().auth.token}`,\n                },\n            });\n            // succesful request\n            newAction(successType, response);\n        } catch ({response}) {\n            // failed request\n            newAction(failType, response);\n        }\n    };\n\nexport const wrapPost = (endpoint, [startType, successType, failType], data) =>\n    async (dispatch, getState) => {\n        // creates a new action based on the response given\n        const newAction = (type, response) => {\n            dispatch({\n                type,\n                \"payload\": {\n                    response,\n                },\n            });\n        };\n\n        // request starting\n        newAction(startType, {});\n\n        try {\n            const response = await instance.post(endpoint, data, {\n                \"headers\": {\n                    \"Authorization\": `Token ${getState().auth.token}`,\n                },\n            });\n            // succesful request\n            newAction(successType, response);\n        } catch ({response}) {\n            // failed request\n            newAction(failType, response);\n        }\n    };\n\nexport const wrapPatch = (endpoint, [startType, successType, failType], id, data) =>\n    async (dispatch, getState) => {\n        // creates a new action based on the response given\n        const newAction = (type, response) => {\n            dispatch({\n                type,\n                \"payload\": {\n                    id,\n                    response,\n                },\n            });\n        };\n\n        // request starting\n        newAction(startType, {});\n\n        try {\n            const response = await instance.patch(`${endpoint}${id}/`, data, {\n                \"headers\": {\n                    \"Authorization\": `Token ${getState().auth.token}`,\n                },\n            });\n            // succesful request\n            newAction(successType, response);\n        } catch ({response}) {\n            // failed request\n            newAction(failType, response);\n        }\n    };\n\nexport const fetchCourses = (id) =>\n    wrapGet(\n        \"/courses/catalog/\",\n        [\n            types.FETCH_COURSE_STARTED,\n            types.FETCH_COURSE_SUCCESSFUL,\n            types.FETCH_COURSE_FAILED,\n        ],\n        id,\n    );\n\nexport const fetchInstructors = (id) =>\n    wrapGet(\n        \"/account/instructor/\",\n        [\n            types.FETCH_INSTRUCTOR_STARTED,\n            types.FETCH_INSTRUCTOR_SUCCESSFUL,\n            types.FETCH_INSTRUCTOR_FAILED,\n        ],\n        id,\n    );\n"]},"metadata":{},"sourceType":"module"}