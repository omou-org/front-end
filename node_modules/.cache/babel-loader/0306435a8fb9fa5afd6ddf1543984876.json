{"ast":null,"code":"/*!\nFullCalendar Time Grid Plugin v4.3.0\nDocs & License: https://fullcalendar.io/\n(c) 2019 Adam Shaw\n*/\nimport { createFormatter, removeElement, cssToStr, isMultiDayRange, htmlEscape, compareByFieldSpecs, applyStyle, FgEventRenderer, buildSegCompareObj, FillRenderer, memoizeRendering, createDuration, wholeDivideDurations, findElements, PositionCache, startOfDay, asRoughMs, formatIsoTimeString, addDurations, htmlToElement, createElement, multiplyDuration, DateComponent, hasBgRendering, Splitter, diffDays, buildGotoAnchorHtml, getAllDayHtml, ScrollComponent, matchCellWidths, uncompensateScroll, compensateScroll, subtractInnerElHeight, View, memoize, intersectRanges, Slicer, DayHeader, DaySeries, DayTable, createPlugin } from '@fullcalendar/core';\nimport { DayBgRow, DayGrid, SimpleDayGrid } from '@fullcalendar/daygrid';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n/*\nOnly handles foreground segs.\nDoes not own rendering. Use for low-level util methods by TimeGrid.\n*/\n\n\nvar TimeGridEventRenderer =\n/** @class */\nfunction (_super) {\n  __extends(TimeGridEventRenderer, _super);\n\n  function TimeGridEventRenderer(timeGrid) {\n    var _this = _super.call(this, timeGrid.context) || this;\n\n    _this.timeGrid = timeGrid;\n    _this.fullTimeFormat = createFormatter({\n      hour: 'numeric',\n      minute: '2-digit',\n      separator: _this.context.options.defaultRangeSeparator\n    });\n    return _this;\n  } // Given an array of foreground segments, render a DOM element for each, computes position,\n  // and attaches to the column inner-container elements.\n\n\n  TimeGridEventRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    var segsByCol = this.timeGrid.groupSegsByCol(segs); // order the segs within each column\n    // TODO: have groupSegsByCol do this?\n\n    for (var col = 0; col < segsByCol.length; col++) {\n      segsByCol[col] = this.sortEventSegs(segsByCol[col]);\n    }\n\n    this.segsByCol = segsByCol;\n    this.timeGrid.attachSegsByCol(segsByCol, this.timeGrid.fgContainerEls);\n  };\n\n  TimeGridEventRenderer.prototype.detachSegs = function (segs) {\n    segs.forEach(function (seg) {\n      removeElement(seg.el);\n    });\n    this.segsByCol = null;\n  };\n\n  TimeGridEventRenderer.prototype.computeSegSizes = function (allSegs) {\n    var _a = this,\n        timeGrid = _a.timeGrid,\n        segsByCol = _a.segsByCol;\n\n    var colCnt = timeGrid.colCnt;\n    timeGrid.computeSegVerticals(allSegs); // horizontals relies on this\n\n    if (segsByCol) {\n      for (var col = 0; col < colCnt; col++) {\n        this.computeSegHorizontals(segsByCol[col]); // compute horizontal coordinates, z-index's, and reorder the array\n      }\n    }\n  };\n\n  TimeGridEventRenderer.prototype.assignSegSizes = function (allSegs) {\n    var _a = this,\n        timeGrid = _a.timeGrid,\n        segsByCol = _a.segsByCol;\n\n    var colCnt = timeGrid.colCnt;\n    timeGrid.assignSegVerticals(allSegs); // horizontals relies on this\n\n    if (segsByCol) {\n      for (var col = 0; col < colCnt; col++) {\n        this.assignSegCss(segsByCol[col]);\n      }\n    }\n  }; // Computes a default event time formatting string if `eventTimeFormat` is not explicitly defined\n\n\n  TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {\n    return {\n      hour: 'numeric',\n      minute: '2-digit',\n      meridiem: false\n    };\n  }; // Computes a default `displayEventEnd` value if one is not expliclty defined\n\n\n  TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {\n    return true;\n  }; // Renders the HTML for a single event segment's default rendering\n\n\n  TimeGridEventRenderer.prototype.renderSegHtml = function (seg, mirrorInfo) {\n    var view = this.context.view;\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var eventUi = eventRange.ui;\n    var allDay = eventDef.allDay;\n    var isDraggable = view.computeEventDraggable(eventDef, eventUi);\n    var isResizableFromStart = seg.isStart && view.computeEventStartResizable(eventDef, eventUi);\n    var isResizableFromEnd = seg.isEnd && view.computeEventEndResizable(eventDef, eventUi);\n    var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd, mirrorInfo);\n    var skinCss = cssToStr(this.getSkinCss(eventUi));\n    var timeText;\n    var fullTimeText; // more verbose time text. for the print stylesheet\n\n    var startTimeText; // just the start time text\n\n    classes.unshift('fc-time-grid-event'); // if the event appears to span more than one day...\n\n    if (isMultiDayRange(eventRange.range)) {\n      // Don't display time text on segments that run entirely through a day.\n      // That would appear as midnight-midnight and would look dumb.\n      // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)\n      if (seg.isStart || seg.isEnd) {\n        var unzonedStart = seg.start;\n        var unzonedEnd = seg.end;\n        timeText = this._getTimeText(unzonedStart, unzonedEnd, allDay); // TODO: give the timezones\n\n        fullTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, this.fullTimeFormat);\n        startTimeText = this._getTimeText(unzonedStart, unzonedEnd, allDay, null, false); // displayEnd=false\n      }\n    } else {\n      // Display the normal time text for the *event's* times\n      timeText = this.getTimeText(eventRange);\n      fullTimeText = this.getTimeText(eventRange, this.fullTimeFormat);\n      startTimeText = this.getTimeText(eventRange, null, false); // displayEnd=false\n    }\n\n    return '<a class=\"' + classes.join(' ') + '\"' + (eventDef.url ? ' href=\"' + htmlEscape(eventDef.url) + '\"' : '') + (skinCss ? ' style=\"' + skinCss + '\"' : '') + '>' + '<div class=\"fc-content\">' + (timeText ? '<div class=\"fc-time\"' + ' data-start=\"' + htmlEscape(startTimeText) + '\"' + ' data-full=\"' + htmlEscape(fullTimeText) + '\"' + '>' + '<span>' + htmlEscape(timeText) + '</span>' + '</div>' : '') + (eventDef.title ? '<div class=\"fc-title\">' + htmlEscape(eventDef.title) + '</div>' : '') + '</div>' + (\n    /* TODO: write CSS for this\n    (isResizableFromStart ?\n      '<div class=\"fc-resizer fc-start-resizer\"></div>' :\n      ''\n      ) +\n    */\n    isResizableFromEnd ? '<div class=\"fc-resizer fc-end-resizer\"></div>' : '') + '</a>';\n  }; // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.\n  // Assumed the segs are already ordered.\n  // NOTE: Also reorders the given array by date!\n\n\n  TimeGridEventRenderer.prototype.computeSegHorizontals = function (segs) {\n    var levels;\n    var level0;\n    var i;\n    levels = buildSlotSegLevels(segs);\n    computeForwardSlotSegs(levels);\n\n    if (level0 = levels[0]) {\n      for (i = 0; i < level0.length; i++) {\n        computeSlotSegPressures(level0[i]);\n      }\n\n      for (i = 0; i < level0.length; i++) {\n        this.computeSegForwardBack(level0[i], 0, 0);\n      }\n    }\n  }; // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range\n  // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to \"left\" and\n  // seg.forwardCoord maps to \"right\" (via percentage). Vice-versa if the calendar is right-to-left.\n  //\n  // The segment might be part of a \"series\", which means consecutive segments with the same pressure\n  // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of\n  // segments behind this one in the current series, and `seriesBackwardCoord` is the starting\n  // coordinate of the first segment in the series.\n\n\n  TimeGridEventRenderer.prototype.computeSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {\n    var forwardSegs = seg.forwardSegs;\n    var i;\n\n    if (seg.forwardCoord === undefined) {\n      // not already computed\n      if (!forwardSegs.length) {\n        // if there are no forward segments, this segment should butt up against the edge\n        seg.forwardCoord = 1;\n      } else {\n        // sort highest pressure first\n        this.sortForwardSegs(forwardSegs); // this segment's forwardCoord will be calculated from the backwardCoord of the\n        // highest-pressure forward segment.\n\n        this.computeSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);\n        seg.forwardCoord = forwardSegs[0].backwardCoord;\n      } // calculate the backwardCoord from the forwardCoord. consider the series\n\n\n      seg.backwardCoord = seg.forwardCoord - (seg.forwardCoord - seriesBackwardCoord) / ( // available width for series\n      seriesBackwardPressure + 1); // # of segments in the series\n      // use this segment's coordinates to computed the coordinates of the less-pressurized\n      // forward segments\n\n      for (i = 0; i < forwardSegs.length; i++) {\n        this.computeSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);\n      }\n    }\n  };\n\n  TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {\n    var objs = forwardSegs.map(buildTimeGridSegCompareObj);\n    var specs = [// put higher-pressure first\n    {\n      field: 'forwardPressure',\n      order: -1\n    }, // put segments that are closer to initial edge first (and favor ones with no coords yet)\n    {\n      field: 'backwardCoord',\n      order: 1\n    }].concat(this.context.view.eventOrderSpecs);\n    objs.sort(function (obj0, obj1) {\n      return compareByFieldSpecs(obj0, obj1, specs);\n    });\n    return objs.map(function (c) {\n      return c._seg;\n    });\n  }; // Given foreground event segments that have already had their position coordinates computed,\n  // assigns position-related CSS values to their elements.\n\n\n  TimeGridEventRenderer.prototype.assignSegCss = function (segs) {\n    for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n      var seg = segs_1[_i];\n      applyStyle(seg.el, this.generateSegCss(seg));\n\n      if (seg.level > 0) {\n        seg.el.classList.add('fc-time-grid-event-inset');\n      } // if the event is short that the title will be cut off,\n      // attach a className that condenses the title into the time area.\n\n\n      if (seg.eventRange.def.title && seg.bottom - seg.top < 30) {\n        seg.el.classList.add('fc-short'); // TODO: \"condensed\" is a better name\n      }\n    }\n  }; // Generates an object with CSS properties/values that should be applied to an event segment element.\n  // Contains important positioning-related properties that should be applied to any event element, customized or not.\n\n\n  TimeGridEventRenderer.prototype.generateSegCss = function (seg) {\n    var shouldOverlap = this.context.options.slotEventOverlap;\n    var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point\n\n    var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point\n\n    var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first\n\n    var isRtl = this.timeGrid.isRtl;\n    var left; // amount of space from left edge, a fraction of the total width\n\n    var right; // amount of space from right edge, a fraction of the total width\n\n    if (shouldOverlap) {\n      // double the width, but don't go beyond the maximum forward coordinate (1.0)\n      forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);\n    }\n\n    if (isRtl) {\n      left = 1 - forwardCoord;\n      right = backwardCoord;\n    } else {\n      left = backwardCoord;\n      right = 1 - forwardCoord;\n    }\n\n    props.zIndex = seg.level + 1; // convert from 0-base to 1-based\n\n    props.left = left * 100 + '%';\n    props.right = right * 100 + '%';\n\n    if (shouldOverlap && seg.forwardPressure) {\n      // add padding to the edge so that forward stacked events don't cover the resizer's icon\n      props[isRtl ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width\n    }\n\n    return props;\n  };\n\n  return TimeGridEventRenderer;\n}(FgEventRenderer); // Builds an array of segments \"levels\". The first level will be the leftmost tier of segments if the calendar is\n// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.\n\n\nfunction buildSlotSegLevels(segs) {\n  var levels = [];\n  var i;\n  var seg;\n  var j;\n\n  for (i = 0; i < segs.length; i++) {\n    seg = segs[i]; // go through all the levels and stop on the first level where there are no collisions\n\n    for (j = 0; j < levels.length; j++) {\n      if (!computeSlotSegCollisions(seg, levels[j]).length) {\n        break;\n      }\n    }\n\n    seg.level = j;\n    (levels[j] || (levels[j] = [])).push(seg);\n  }\n\n  return levels;\n} // For every segment, figure out the other segments that are in subsequent\n// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs\n\n\nfunction computeForwardSlotSegs(levels) {\n  var i;\n  var level;\n  var j;\n  var seg;\n  var k;\n\n  for (i = 0; i < levels.length; i++) {\n    level = levels[i];\n\n    for (j = 0; j < level.length; j++) {\n      seg = level[j];\n      seg.forwardSegs = [];\n\n      for (k = i + 1; k < levels.length; k++) {\n        computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);\n      }\n    }\n  }\n} // Figure out which path forward (via seg.forwardSegs) results in the longest path until\n// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure\n\n\nfunction computeSlotSegPressures(seg) {\n  var forwardSegs = seg.forwardSegs;\n  var forwardPressure = 0;\n  var i;\n  var forwardSeg;\n\n  if (seg.forwardPressure === undefined) {\n    // not already computed\n    for (i = 0; i < forwardSegs.length; i++) {\n      forwardSeg = forwardSegs[i]; // figure out the child's maximum forward path\n\n      computeSlotSegPressures(forwardSeg); // either use the existing maximum, or use the child's forward pressure\n      // plus one (for the forwardSeg itself)\n\n      forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);\n    }\n\n    seg.forwardPressure = forwardPressure;\n  }\n} // Find all the segments in `otherSegs` that vertically collide with `seg`.\n// Append into an optionally-supplied `results` array and return.\n\n\nfunction computeSlotSegCollisions(seg, otherSegs, results) {\n  if (results === void 0) {\n    results = [];\n  }\n\n  for (var i = 0; i < otherSegs.length; i++) {\n    if (isSlotSegCollision(seg, otherSegs[i])) {\n      results.push(otherSegs[i]);\n    }\n  }\n\n  return results;\n} // Do these segments occupy the same vertical space?\n\n\nfunction isSlotSegCollision(seg1, seg2) {\n  return seg1.bottom > seg2.top && seg1.top < seg2.bottom;\n}\n\nfunction buildTimeGridSegCompareObj(seg) {\n  var obj = buildSegCompareObj(seg);\n  obj.forwardPressure = seg.forwardPressure;\n  obj.backwardCoord = seg.backwardCoord;\n  return obj;\n}\n\nvar TimeGridMirrorRenderer =\n/** @class */\nfunction (_super) {\n  __extends(TimeGridMirrorRenderer, _super);\n\n  function TimeGridMirrorRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeGridMirrorRenderer.prototype.attachSegs = function (segs, mirrorInfo) {\n    this.segsByCol = this.timeGrid.groupSegsByCol(segs);\n    this.timeGrid.attachSegsByCol(this.segsByCol, this.timeGrid.mirrorContainerEls);\n    this.sourceSeg = mirrorInfo.sourceSeg;\n  };\n\n  TimeGridMirrorRenderer.prototype.generateSegCss = function (seg) {\n    var props = _super.prototype.generateSegCss.call(this, seg);\n\n    var sourceSeg = this.sourceSeg;\n\n    if (sourceSeg && sourceSeg.col === seg.col) {\n      var sourceSegProps = _super.prototype.generateSegCss.call(this, sourceSeg);\n\n      props.left = sourceSegProps.left;\n      props.right = sourceSegProps.right;\n      props.marginLeft = sourceSegProps.marginLeft;\n      props.marginRight = sourceSegProps.marginRight;\n    }\n\n    return props;\n  };\n\n  return TimeGridMirrorRenderer;\n}(TimeGridEventRenderer);\n\nvar TimeGridFillRenderer =\n/** @class */\nfunction (_super) {\n  __extends(TimeGridFillRenderer, _super);\n\n  function TimeGridFillRenderer(timeGrid) {\n    var _this = _super.call(this, timeGrid.context) || this;\n\n    _this.timeGrid = timeGrid;\n    return _this;\n  }\n\n  TimeGridFillRenderer.prototype.attachSegs = function (type, segs) {\n    var timeGrid = this.timeGrid;\n    var containerEls; // TODO: more efficient lookup\n\n    if (type === 'bgEvent') {\n      containerEls = timeGrid.bgContainerEls;\n    } else if (type === 'businessHours') {\n      containerEls = timeGrid.businessContainerEls;\n    } else if (type === 'highlight') {\n      containerEls = timeGrid.highlightContainerEls;\n    }\n\n    timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);\n    return segs.map(function (seg) {\n      return seg.el;\n    });\n  };\n\n  TimeGridFillRenderer.prototype.computeSegSizes = function (segs) {\n    this.timeGrid.computeSegVerticals(segs);\n  };\n\n  TimeGridFillRenderer.prototype.assignSegSizes = function (segs) {\n    this.timeGrid.assignSegVerticals(segs);\n  };\n\n  return TimeGridFillRenderer;\n}(FillRenderer);\n/* A component that renders one or more columns of vertical time slots\n----------------------------------------------------------------------------------------------------------------------*/\n// potential nice values for the slot-duration and interval-duration\n// from largest to smallest\n\n\nvar AGENDA_STOCK_SUB_DURATIONS = [{\n  hours: 1\n}, {\n  minutes: 30\n}, {\n  minutes: 15\n}, {\n  seconds: 30\n}, {\n  seconds: 15\n}];\n\nvar TimeGrid =\n/** @class */\nfunction (_super) {\n  __extends(TimeGrid, _super);\n\n  function TimeGrid(context, el, renderProps) {\n    var _this = _super.call(this, context, el) || this;\n\n    _this.isSlatSizesDirty = false;\n    _this.isColSizesDirty = false;\n    _this.renderSlats = memoizeRendering(_this._renderSlats);\n    var eventRenderer = _this.eventRenderer = new TimeGridEventRenderer(_this);\n    var fillRenderer = _this.fillRenderer = new TimeGridFillRenderer(_this);\n    _this.mirrorRenderer = new TimeGridMirrorRenderer(_this);\n    var renderColumns = _this.renderColumns = memoizeRendering(_this._renderColumns, _this._unrenderColumns);\n    _this.renderBusinessHours = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'businessHours'), fillRenderer.unrender.bind(fillRenderer, 'businessHours'), [renderColumns]);\n    _this.renderDateSelection = memoizeRendering(_this._renderDateSelection, _this._unrenderDateSelection, [renderColumns]);\n    _this.renderFgEvents = memoizeRendering(eventRenderer.renderSegs.bind(eventRenderer), eventRenderer.unrender.bind(eventRenderer), [renderColumns]);\n    _this.renderBgEvents = memoizeRendering(fillRenderer.renderSegs.bind(fillRenderer, 'bgEvent'), fillRenderer.unrender.bind(fillRenderer, 'bgEvent'), [renderColumns]);\n    _this.renderEventSelection = memoizeRendering(eventRenderer.selectByInstanceId.bind(eventRenderer), eventRenderer.unselectByInstanceId.bind(eventRenderer), [_this.renderFgEvents]);\n    _this.renderEventDrag = memoizeRendering(_this._renderEventDrag, _this._unrenderEventDrag, [renderColumns]);\n    _this.renderEventResize = memoizeRendering(_this._renderEventResize, _this._unrenderEventResize, [renderColumns]);\n\n    _this.processOptions();\n\n    el.innerHTML = '<div class=\"fc-bg\"></div>' + '<div class=\"fc-slats\"></div>' + '<hr class=\"fc-divider ' + _this.theme.getClass('widgetHeader') + '\" style=\"display:none\" />';\n    _this.rootBgContainerEl = el.querySelector('.fc-bg');\n    _this.slatContainerEl = el.querySelector('.fc-slats');\n    _this.bottomRuleEl = el.querySelector('.fc-divider');\n    _this.renderProps = renderProps;\n    return _this;\n  }\n  /* Options\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Parses various options into properties of this object\n\n\n  TimeGrid.prototype.processOptions = function () {\n    var slotDuration = this.opt('slotDuration');\n    var snapDuration = this.opt('snapDuration');\n    var snapsPerSlot;\n    var input;\n    slotDuration = createDuration(slotDuration);\n    snapDuration = snapDuration ? createDuration(snapDuration) : slotDuration;\n    snapsPerSlot = wholeDivideDurations(slotDuration, snapDuration);\n\n    if (snapsPerSlot === null) {\n      snapDuration = slotDuration;\n      snapsPerSlot = 1; // TODO: say warning?\n    }\n\n    this.slotDuration = slotDuration;\n    this.snapDuration = snapDuration;\n    this.snapsPerSlot = snapsPerSlot; // might be an array value (for TimelineView).\n    // if so, getting the most granular entry (the last one probably).\n\n    input = this.opt('slotLabelFormat');\n\n    if (Array.isArray(input)) {\n      input = input[input.length - 1];\n    }\n\n    this.labelFormat = createFormatter(input || {\n      hour: 'numeric',\n      minute: '2-digit',\n      omitZeroMinute: true,\n      meridiem: 'short'\n    });\n    input = this.opt('slotLabelInterval');\n    this.labelInterval = input ? createDuration(input) : this.computeLabelInterval(slotDuration);\n  }; // Computes an automatic value for slotLabelInterval\n\n\n  TimeGrid.prototype.computeLabelInterval = function (slotDuration) {\n    var i;\n    var labelInterval;\n    var slotsPerLabel; // find the smallest stock label interval that results in more than one slots-per-label\n\n    for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {\n      labelInterval = createDuration(AGENDA_STOCK_SUB_DURATIONS[i]);\n      slotsPerLabel = wholeDivideDurations(labelInterval, slotDuration);\n\n      if (slotsPerLabel !== null && slotsPerLabel > 1) {\n        return labelInterval;\n      }\n    }\n\n    return slotDuration; // fall back\n  };\n  /* Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype.render = function (props) {\n    var cells = props.cells;\n    this.colCnt = cells.length;\n    this.renderSlats(props.dateProfile);\n    this.renderColumns(props.cells, props.dateProfile);\n    this.renderBusinessHours(props.businessHourSegs);\n    this.renderDateSelection(props.dateSelectionSegs);\n    this.renderFgEvents(props.fgEventSegs);\n    this.renderBgEvents(props.bgEventSegs);\n    this.renderEventSelection(props.eventSelection);\n    this.renderEventDrag(props.eventDrag);\n    this.renderEventResize(props.eventResize);\n  };\n\n  TimeGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this); // should unrender everything else too\n\n\n    this.renderSlats.unrender();\n    this.renderColumns.unrender();\n  };\n\n  TimeGrid.prototype.updateSize = function (isResize) {\n    var _a = this,\n        fillRenderer = _a.fillRenderer,\n        eventRenderer = _a.eventRenderer,\n        mirrorRenderer = _a.mirrorRenderer;\n\n    if (isResize || this.isSlatSizesDirty) {\n      this.buildSlatPositions();\n      this.isSlatSizesDirty = false;\n    }\n\n    if (isResize || this.isColSizesDirty) {\n      this.buildColPositions();\n      this.isColSizesDirty = false;\n    }\n\n    fillRenderer.computeSizes(isResize);\n    eventRenderer.computeSizes(isResize);\n    mirrorRenderer.computeSizes(isResize);\n    fillRenderer.assignSizes(isResize);\n    eventRenderer.assignSizes(isResize);\n    mirrorRenderer.assignSizes(isResize);\n  };\n\n  TimeGrid.prototype._renderSlats = function (dateProfile) {\n    var theme = this.theme;\n    this.slatContainerEl.innerHTML = '<table class=\"' + theme.getClass('tableGrid') + '\">' + this.renderSlatRowHtml(dateProfile) + '</table>';\n    this.slatEls = findElements(this.slatContainerEl, 'tr');\n    this.slatPositions = new PositionCache(this.el, this.slatEls, false, true // vertical\n    );\n    this.isSlatSizesDirty = true;\n  }; // Generates the HTML for the horizontal \"slats\" that run width-wise. Has a time axis on a side. Depends on RTL.\n\n\n  TimeGrid.prototype.renderSlatRowHtml = function (dateProfile) {\n    var _a = this,\n        dateEnv = _a.dateEnv,\n        theme = _a.theme,\n        isRtl = _a.isRtl;\n\n    var html = '';\n    var dayStart = startOfDay(dateProfile.renderRange.start);\n    var slotTime = dateProfile.minTime;\n    var slotIterator = createDuration(0);\n    var slotDate; // will be on the view's first day, but we only care about its time\n\n    var isLabeled;\n    var axisHtml; // Calculate the time for each slot\n\n    while (asRoughMs(slotTime) < asRoughMs(dateProfile.maxTime)) {\n      slotDate = dateEnv.add(dayStart, slotTime);\n      isLabeled = wholeDivideDurations(slotIterator, this.labelInterval) !== null;\n      axisHtml = '<td class=\"fc-axis fc-time ' + theme.getClass('widgetContent') + '\">' + (isLabeled ? '<span>' + // for matchCellWidths\n      htmlEscape(dateEnv.format(slotDate, this.labelFormat)) + '</span>' : '') + '</td>';\n      html += '<tr data-time=\"' + formatIsoTimeString(slotDate) + '\"' + (isLabeled ? '' : ' class=\"fc-minor\"') + '>' + (!isRtl ? axisHtml : '') + '<td class=\"' + theme.getClass('widgetContent') + '\"></td>' + (isRtl ? axisHtml : '') + '</tr>';\n      slotTime = addDurations(slotTime, this.slotDuration);\n      slotIterator = addDurations(slotIterator, this.slotDuration);\n    }\n\n    return html;\n  };\n\n  TimeGrid.prototype._renderColumns = function (cells, dateProfile) {\n    var _a = this,\n        theme = _a.theme,\n        dateEnv = _a.dateEnv,\n        view = _a.view;\n\n    var bgRow = new DayBgRow(this.context);\n    this.rootBgContainerEl.innerHTML = '<table class=\"' + theme.getClass('tableGrid') + '\">' + bgRow.renderHtml({\n      cells: cells,\n      dateProfile: dateProfile,\n      renderIntroHtml: this.renderProps.renderBgIntroHtml\n    }) + '</table>';\n    this.colEls = findElements(this.el, '.fc-day, .fc-disabled-day');\n\n    for (var col = 0; col < this.colCnt; col++) {\n      this.publiclyTrigger('dayRender', [{\n        date: dateEnv.toDate(cells[col].date),\n        el: this.colEls[col],\n        view: view\n      }]);\n    }\n\n    if (this.isRtl) {\n      this.colEls.reverse();\n    }\n\n    this.colPositions = new PositionCache(this.el, this.colEls, true, // horizontal\n    false);\n    this.renderContentSkeleton();\n    this.isColSizesDirty = true;\n  };\n\n  TimeGrid.prototype._unrenderColumns = function () {\n    this.unrenderContentSkeleton();\n  };\n  /* Content Skeleton\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Renders the DOM that the view's content will live in\n\n\n  TimeGrid.prototype.renderContentSkeleton = function () {\n    var parts = [];\n    var skeletonEl;\n    parts.push(this.renderProps.renderIntroHtml());\n\n    for (var i = 0; i < this.colCnt; i++) {\n      parts.push('<td>' + '<div class=\"fc-content-col\">' + '<div class=\"fc-event-container fc-mirror-container\"></div>' + '<div class=\"fc-event-container\"></div>' + '<div class=\"fc-highlight-container\"></div>' + '<div class=\"fc-bgevent-container\"></div>' + '<div class=\"fc-business-container\"></div>' + '</div>' + '</td>');\n    }\n\n    if (this.isRtl) {\n      parts.reverse();\n    }\n\n    skeletonEl = this.contentSkeletonEl = htmlToElement('<div class=\"fc-content-skeleton\">' + '<table>' + '<tr>' + parts.join('') + '</tr>' + '</table>' + '</div>');\n    this.colContainerEls = findElements(skeletonEl, '.fc-content-col');\n    this.mirrorContainerEls = findElements(skeletonEl, '.fc-mirror-container');\n    this.fgContainerEls = findElements(skeletonEl, '.fc-event-container:not(.fc-mirror-container)');\n    this.bgContainerEls = findElements(skeletonEl, '.fc-bgevent-container');\n    this.highlightContainerEls = findElements(skeletonEl, '.fc-highlight-container');\n    this.businessContainerEls = findElements(skeletonEl, '.fc-business-container');\n\n    if (this.isRtl) {\n      this.colContainerEls.reverse();\n      this.mirrorContainerEls.reverse();\n      this.fgContainerEls.reverse();\n      this.bgContainerEls.reverse();\n      this.highlightContainerEls.reverse();\n      this.businessContainerEls.reverse();\n    }\n\n    this.el.appendChild(skeletonEl);\n  };\n\n  TimeGrid.prototype.unrenderContentSkeleton = function () {\n    removeElement(this.contentSkeletonEl);\n  }; // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col\n\n\n  TimeGrid.prototype.groupSegsByCol = function (segs) {\n    var segsByCol = [];\n    var i;\n\n    for (i = 0; i < this.colCnt; i++) {\n      segsByCol.push([]);\n    }\n\n    for (i = 0; i < segs.length; i++) {\n      segsByCol[segs[i].col].push(segs[i]);\n    }\n\n    return segsByCol;\n  }; // Given segments grouped by column, insert the segments' elements into a parallel array of container\n  // elements, each living within a column.\n\n\n  TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {\n    var col;\n    var segs;\n    var i;\n\n    for (col = 0; col < this.colCnt; col++) {\n      // iterate each column grouping\n      segs = segsByCol[col];\n\n      for (i = 0; i < segs.length; i++) {\n        containerEls[col].appendChild(segs[i].el);\n      }\n    }\n  };\n  /* Now Indicator\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype.getNowIndicatorUnit = function () {\n    return 'minute'; // will refresh on the minute\n  };\n\n  TimeGrid.prototype.renderNowIndicator = function (segs, date) {\n    // HACK: if date columns not ready for some reason (scheduler)\n    if (!this.colContainerEls) {\n      return;\n    }\n\n    var top = this.computeDateTop(date);\n    var nodes = [];\n    var i; // render lines within the columns\n\n    for (i = 0; i < segs.length; i++) {\n      var lineEl = createElement('div', {\n        className: 'fc-now-indicator fc-now-indicator-line'\n      });\n      lineEl.style.top = top + 'px';\n      this.colContainerEls[segs[i].col].appendChild(lineEl);\n      nodes.push(lineEl);\n    } // render an arrow over the axis\n\n\n    if (segs.length > 0) {\n      // is the current time in view?\n      var arrowEl = createElement('div', {\n        className: 'fc-now-indicator fc-now-indicator-arrow'\n      });\n      arrowEl.style.top = top + 'px';\n      this.contentSkeletonEl.appendChild(arrowEl);\n      nodes.push(arrowEl);\n    }\n\n    this.nowIndicatorEls = nodes;\n  };\n\n  TimeGrid.prototype.unrenderNowIndicator = function () {\n    if (this.nowIndicatorEls) {\n      this.nowIndicatorEls.forEach(removeElement);\n      this.nowIndicatorEls = null;\n    }\n  };\n  /* Coordinates\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype.getTotalSlatHeight = function () {\n    return this.slatContainerEl.getBoundingClientRect().height;\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given date.\n  // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.\n\n\n  TimeGrid.prototype.computeDateTop = function (when, startOfDayDate) {\n    if (!startOfDayDate) {\n      startOfDayDate = startOfDay(when);\n    }\n\n    return this.computeTimeTop(createDuration(when.valueOf() - startOfDayDate.valueOf()));\n  }; // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).\n\n\n  TimeGrid.prototype.computeTimeTop = function (duration) {\n    var len = this.slatEls.length;\n    var dateProfile = this.props.dateProfile;\n    var slatCoverage = (duration.milliseconds - asRoughMs(dateProfile.minTime)) / asRoughMs(this.slotDuration); // floating-point value of # of slots covered\n\n    var slatIndex;\n    var slatRemainder; // compute a floating-point number for how many slats should be progressed through.\n    // from 0 to number of slats (inclusive)\n    // constrained because minTime/maxTime might be customized.\n\n    slatCoverage = Math.max(0, slatCoverage);\n    slatCoverage = Math.min(len, slatCoverage); // an integer index of the furthest whole slat\n    // from 0 to number slats (*exclusive*, so len-1)\n\n    slatIndex = Math.floor(slatCoverage);\n    slatIndex = Math.min(slatIndex, len - 1); // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.\n    // could be 1.0 if slatCoverage is covering *all* the slots\n\n    slatRemainder = slatCoverage - slatIndex;\n    return this.slatPositions.tops[slatIndex] + this.slatPositions.getHeight(slatIndex) * slatRemainder;\n  }; // For each segment in an array, computes and assigns its top and bottom properties\n\n\n  TimeGrid.prototype.computeSegVerticals = function (segs) {\n    var eventMinHeight = this.opt('timeGridEventMinHeight');\n    var i;\n    var seg;\n    var dayDate;\n\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      dayDate = this.props.cells[seg.col].date;\n      seg.top = this.computeDateTop(seg.start, dayDate);\n      seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.end, dayDate));\n    }\n  }; // Given segments that already have their top/bottom properties computed, applies those values to\n  // the segments' elements.\n\n\n  TimeGrid.prototype.assignSegVerticals = function (segs) {\n    var i;\n    var seg;\n\n    for (i = 0; i < segs.length; i++) {\n      seg = segs[i];\n      applyStyle(seg.el, this.generateSegVerticalCss(seg));\n    }\n  }; // Generates an object with CSS properties for the top/bottom coordinates of a segment element\n\n\n  TimeGrid.prototype.generateSegVerticalCss = function (seg) {\n    return {\n      top: seg.top,\n      bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container\n\n    };\n  };\n  /* Sizing\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype.buildPositionCaches = function () {\n    this.buildColPositions();\n    this.buildSlatPositions();\n  };\n\n  TimeGrid.prototype.buildColPositions = function () {\n    this.colPositions.build();\n  };\n\n  TimeGrid.prototype.buildSlatPositions = function () {\n    this.slatPositions.build();\n  };\n  /* Hit System\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype.positionToHit = function (positionLeft, positionTop) {\n    var _a = this,\n        dateEnv = _a.dateEnv,\n        snapsPerSlot = _a.snapsPerSlot,\n        slatPositions = _a.slatPositions,\n        colPositions = _a.colPositions;\n\n    var colIndex = colPositions.leftToIndex(positionLeft);\n    var slatIndex = slatPositions.topToIndex(positionTop);\n\n    if (colIndex != null && slatIndex != null) {\n      var slatTop = slatPositions.tops[slatIndex];\n      var slatHeight = slatPositions.getHeight(slatIndex);\n      var partial = (positionTop - slatTop) / slatHeight; // floating point number between 0 and 1\n\n      var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat\n\n      var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;\n      var dayDate = this.props.cells[colIndex].date;\n      var time = addDurations(this.props.dateProfile.minTime, multiplyDuration(this.snapDuration, snapIndex));\n      var start = dateEnv.add(dayDate, time);\n      var end = dateEnv.add(start, this.snapDuration);\n      return {\n        col: colIndex,\n        dateSpan: {\n          range: {\n            start: start,\n            end: end\n          },\n          allDay: false\n        },\n        dayEl: this.colEls[colIndex],\n        relativeRect: {\n          left: colPositions.lefts[colIndex],\n          right: colPositions.rights[colIndex],\n          top: slatTop,\n          bottom: slatTop + slatHeight\n        }\n      };\n    }\n  };\n  /* Event Drag Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype._renderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n\n      if (state.isEvent) {\n        this.mirrorRenderer.renderSegs(state.segs, {\n          isDragging: true,\n          sourceSeg: state.sourceSeg\n        });\n      } else {\n        this.fillRenderer.renderSegs('highlight', state.segs);\n      }\n    }\n  };\n\n  TimeGrid.prototype._unrenderEventDrag = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.mirrorRenderer.unrender(state.segs, {\n        isDragging: true,\n        sourceSeg: state.sourceSeg\n      });\n      this.fillRenderer.unrender('highlight');\n    }\n  };\n  /* Event Resize Visualization\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGrid.prototype._renderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.hideByHash(state.affectedInstances);\n      this.mirrorRenderer.renderSegs(state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n\n  TimeGrid.prototype._unrenderEventResize = function (state) {\n    if (state) {\n      this.eventRenderer.showByHash(state.affectedInstances);\n      this.mirrorRenderer.unrender(state.segs, {\n        isResizing: true,\n        sourceSeg: state.sourceSeg\n      });\n    }\n  };\n  /* Selection\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.\n\n\n  TimeGrid.prototype._renderDateSelection = function (segs) {\n    if (segs) {\n      if (this.opt('selectMirror')) {\n        this.mirrorRenderer.renderSegs(segs, {\n          isSelecting: true\n        });\n      } else {\n        this.fillRenderer.renderSegs('highlight', segs);\n      }\n    }\n  };\n\n  TimeGrid.prototype._unrenderDateSelection = function (segs) {\n    this.mirrorRenderer.unrender(segs, {\n      isSelecting: true\n    });\n    this.fillRenderer.unrender('highlight');\n  };\n\n  return TimeGrid;\n}(DateComponent);\n\nvar AllDaySplitter =\n/** @class */\nfunction (_super) {\n  __extends(AllDaySplitter, _super);\n\n  function AllDaySplitter() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AllDaySplitter.prototype.getKeyInfo = function () {\n    return {\n      allDay: {},\n      timed: {}\n    };\n  };\n\n  AllDaySplitter.prototype.getKeysForDateSpan = function (dateSpan) {\n    if (dateSpan.allDay) {\n      return ['allDay'];\n    } else {\n      return ['timed'];\n    }\n  };\n\n  AllDaySplitter.prototype.getKeysForEventDef = function (eventDef) {\n    if (!eventDef.allDay) {\n      return ['timed'];\n    } else if (hasBgRendering(eventDef)) {\n      return ['timed', 'allDay'];\n    } else {\n      return ['allDay'];\n    }\n  };\n\n  return AllDaySplitter;\n}(Splitter);\n\nvar TIMEGRID_ALL_DAY_EVENT_LIMIT = 5;\nvar WEEK_HEADER_FORMAT = createFormatter({\n  week: 'short'\n});\n/* An abstract class for all timegrid-related views. Displays one more columns with time slots running vertically.\n----------------------------------------------------------------------------------------------------------------------*/\n// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).\n// Responsible for managing width/height.\n\nvar TimeGridView =\n/** @class */\nfunction (_super) {\n  __extends(TimeGridView, _super);\n\n  function TimeGridView(context, viewSpec, dateProfileGenerator, parentEl) {\n    var _this = _super.call(this, context, viewSpec, dateProfileGenerator, parentEl) || this;\n\n    _this.splitter = new AllDaySplitter();\n    /* Header Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that will go before the day-of week header cells\n\n    _this.renderHeadIntroHtml = function () {\n      var _a = _this,\n          theme = _a.theme,\n          dateEnv = _a.dateEnv;\n      var range = _this.props.dateProfile.renderRange;\n      var dayCnt = diffDays(range.start, range.end);\n      var weekText;\n\n      if (_this.opt('weekNumbers')) {\n        weekText = dateEnv.format(range.start, WEEK_HEADER_FORMAT);\n        return '' + '<th class=\"fc-axis fc-week-number ' + theme.getClass('widgetHeader') + '\" ' + _this.axisStyleAttr() + '>' + buildGotoAnchorHtml( // aside from link, important for matchCellWidths\n        _this, {\n          date: range.start,\n          type: 'week',\n          forceOff: dayCnt > 1\n        }, htmlEscape(weekText) // inner HTML\n        ) + '</th>';\n      } else {\n        return '<th class=\"fc-axis ' + theme.getClass('widgetHeader') + '\" ' + _this.axisStyleAttr() + '></th>';\n      }\n    };\n    /* Time Grid Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.\n\n\n    _this.renderTimeGridBgIntroHtml = function () {\n      var theme = _this.theme;\n      return '<td class=\"fc-axis ' + theme.getClass('widgetContent') + '\" ' + _this.axisStyleAttr() + '></td>';\n    }; // Generates the HTML that goes before all other types of cells.\n    // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.\n\n\n    _this.renderTimeGridIntroHtml = function () {\n      return '<td class=\"fc-axis\" ' + _this.axisStyleAttr() + '></td>';\n    };\n    /* Day Grid Render Methods\n    ------------------------------------------------------------------------------------------------------------------*/\n    // Generates the HTML that goes before the all-day cells\n\n\n    _this.renderDayGridBgIntroHtml = function () {\n      var theme = _this.theme;\n      return '' + '<td class=\"fc-axis ' + theme.getClass('widgetContent') + '\" ' + _this.axisStyleAttr() + '>' + '<span>' + // needed for matchCellWidths\n      getAllDayHtml(_this) + '</span>' + '</td>';\n    }; // Generates the HTML that goes before all other types of cells.\n    // Affects content-skeleton, mirror-skeleton, highlight-skeleton for both the time-grid and day-grid.\n\n\n    _this.renderDayGridIntroHtml = function () {\n      return '<td class=\"fc-axis\" ' + _this.axisStyleAttr() + '></td>';\n    };\n\n    _this.el.classList.add('fc-timeGrid-view');\n\n    _this.el.innerHTML = _this.renderSkeletonHtml();\n    _this.scroller = new ScrollComponent('hidden', // overflow x\n    'auto' // overflow y\n    );\n    var timeGridWrapEl = _this.scroller.el;\n\n    _this.el.querySelector('.fc-body > tr > td').appendChild(timeGridWrapEl);\n\n    timeGridWrapEl.classList.add('fc-time-grid-container');\n    var timeGridEl = createElement('div', {\n      className: 'fc-time-grid'\n    });\n    timeGridWrapEl.appendChild(timeGridEl);\n    _this.timeGrid = new TimeGrid(_this.context, timeGridEl, {\n      renderBgIntroHtml: _this.renderTimeGridBgIntroHtml,\n      renderIntroHtml: _this.renderTimeGridIntroHtml\n    });\n\n    if (_this.opt('allDaySlot')) {\n      // should we display the \"all-day\" area?\n      _this.dayGrid = new DayGrid( // the all-day subcomponent of this view\n      _this.context, _this.el.querySelector('.fc-day-grid'), {\n        renderNumberIntroHtml: _this.renderDayGridIntroHtml,\n        renderBgIntroHtml: _this.renderDayGridBgIntroHtml,\n        renderIntroHtml: _this.renderDayGridIntroHtml,\n        colWeekNumbersVisible: false,\n        cellWeekNumbersVisible: false\n      }); // have the day-grid extend it's coordinate area over the <hr> dividing the two grids\n\n      var dividerEl = _this.el.querySelector('.fc-divider');\n\n      _this.dayGrid.bottomCoordPadding = dividerEl.getBoundingClientRect().height;\n    }\n\n    return _this;\n  }\n\n  TimeGridView.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.timeGrid.destroy();\n\n    if (this.dayGrid) {\n      this.dayGrid.destroy();\n    }\n\n    this.scroller.destroy();\n  };\n  /* Rendering\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Builds the HTML skeleton for the view.\n  // The day-grid and time-grid components will render inside containers defined by this HTML.\n\n\n  TimeGridView.prototype.renderSkeletonHtml = function () {\n    var theme = this.theme;\n    return '' + '<table class=\"' + theme.getClass('tableGrid') + '\">' + (this.opt('columnHeader') ? '<thead class=\"fc-head\">' + '<tr>' + '<td class=\"fc-head-container ' + theme.getClass('widgetHeader') + '\">&nbsp;</td>' + '</tr>' + '</thead>' : '') + '<tbody class=\"fc-body\">' + '<tr>' + '<td class=\"' + theme.getClass('widgetContent') + '\">' + (this.opt('allDaySlot') ? '<div class=\"fc-day-grid\"></div>' + '<hr class=\"fc-divider ' + theme.getClass('widgetHeader') + '\" />' : '') + '</td>' + '</tr>' + '</tbody>' + '</table>';\n  };\n  /* Now Indicator\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGridView.prototype.getNowIndicatorUnit = function () {\n    return this.timeGrid.getNowIndicatorUnit();\n  }; // subclasses should implement\n  // renderNowIndicator(date: DateMarker) {\n  // }\n\n\n  TimeGridView.prototype.unrenderNowIndicator = function () {\n    this.timeGrid.unrenderNowIndicator();\n  };\n  /* Dimensions\n  ------------------------------------------------------------------------------------------------------------------*/\n\n\n  TimeGridView.prototype.updateSize = function (isResize, viewHeight, isAuto) {\n    _super.prototype.updateSize.call(this, isResize, viewHeight, isAuto); // will call updateBaseSize. important that executes first\n\n\n    this.timeGrid.updateSize(isResize);\n\n    if (this.dayGrid) {\n      this.dayGrid.updateSize(isResize);\n    }\n  }; // Adjusts the vertical dimensions of the view to the specified values\n\n\n  TimeGridView.prototype.updateBaseSize = function (isResize, viewHeight, isAuto) {\n    var _this = this;\n\n    var eventLimit;\n    var scrollerHeight;\n    var scrollbarWidths; // make all axis cells line up\n\n    this.axisWidth = matchCellWidths(findElements(this.el, '.fc-axis')); // hack to give the view some height prior to timeGrid's columns being rendered\n    // TODO: separate setting height from scroller VS timeGrid.\n\n    if (!this.timeGrid.colEls) {\n      if (!isAuto) {\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      }\n\n      return;\n    } // set of fake row elements that must compensate when scroller has scrollbars\n\n\n    var noScrollRowEls = findElements(this.el, '.fc-row').filter(function (node) {\n      return !_this.scroller.el.contains(node);\n    }); // reset all dimensions back to the original state\n\n    this.timeGrid.bottomRuleEl.style.display = 'none'; // will be shown later if this <hr> is necessary\n\n    this.scroller.clear(); // sets height to 'auto' and clears overflow\n\n    noScrollRowEls.forEach(uncompensateScroll); // limit number of events in the all-day area\n\n    if (this.dayGrid) {\n      this.dayGrid.removeSegPopover(); // kill the \"more\" popover if displayed\n\n      eventLimit = this.opt('eventLimit');\n\n      if (eventLimit && typeof eventLimit !== 'number') {\n        eventLimit = TIMEGRID_ALL_DAY_EVENT_LIMIT; // make sure \"auto\" goes to a real number\n      }\n\n      if (eventLimit) {\n        this.dayGrid.limitRows(eventLimit);\n      }\n    }\n\n    if (!isAuto) {\n      // should we force dimensions of the scroll container?\n      scrollerHeight = this.computeScrollerHeight(viewHeight);\n      this.scroller.setHeight(scrollerHeight);\n      scrollbarWidths = this.scroller.getScrollbarWidths();\n\n      if (scrollbarWidths.left || scrollbarWidths.right) {\n        // using scrollbars?\n        // make the all-day and header rows lines up\n        noScrollRowEls.forEach(function (rowEl) {\n          compensateScroll(rowEl, scrollbarWidths);\n        }); // the scrollbar compensation might have changed text flow, which might affect height, so recalculate\n        // and reapply the desired height to the scroller.\n\n        scrollerHeight = this.computeScrollerHeight(viewHeight);\n        this.scroller.setHeight(scrollerHeight);\n      } // guarantees the same scrollbar widths\n\n\n      this.scroller.lockOverflow(scrollbarWidths); // if there's any space below the slats, show the horizontal rule.\n      // this won't cause any new overflow, because lockOverflow already called.\n\n      if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {\n        this.timeGrid.bottomRuleEl.style.display = '';\n      }\n    }\n  }; // given a desired total height of the view, returns what the height of the scroller should be\n\n\n  TimeGridView.prototype.computeScrollerHeight = function (viewHeight) {\n    return viewHeight - subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller\n  };\n  /* Scroll\n  ------------------------------------------------------------------------------------------------------------------*/\n  // Computes the initial pre-configured scroll state prior to allowing the user to change it\n\n\n  TimeGridView.prototype.computeDateScroll = function (duration) {\n    var top = this.timeGrid.computeTimeTop(duration); // zoom can give weird floating-point values. rather scroll a little bit further\n\n    top = Math.ceil(top);\n\n    if (top) {\n      top++; // to overcome top border that slots beyond the first have. looks better\n    }\n\n    return {\n      top: top\n    };\n  };\n\n  TimeGridView.prototype.queryDateScroll = function () {\n    return {\n      top: this.scroller.getScrollTop()\n    };\n  };\n\n  TimeGridView.prototype.applyDateScroll = function (scroll) {\n    if (scroll.top !== undefined) {\n      this.scroller.setScrollTop(scroll.top);\n    }\n  }; // Generates an HTML attribute string for setting the width of the axis, if it is known\n\n\n  TimeGridView.prototype.axisStyleAttr = function () {\n    if (this.axisWidth != null) {\n      return 'style=\"width:' + this.axisWidth + 'px\"';\n    }\n\n    return '';\n  };\n\n  return TimeGridView;\n}(View);\n\nTimeGridView.prototype.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering\n\nvar SimpleTimeGrid =\n/** @class */\nfunction (_super) {\n  __extends(SimpleTimeGrid, _super);\n\n  function SimpleTimeGrid(context, timeGrid) {\n    var _this = _super.call(this, context, timeGrid.el) || this;\n\n    _this.buildDayRanges = memoize(buildDayRanges);\n    _this.slicer = new TimeGridSlicer();\n    _this.timeGrid = timeGrid;\n    context.calendar.registerInteractiveComponent(_this, {\n      el: _this.timeGrid.el\n    });\n    return _this;\n  }\n\n  SimpleTimeGrid.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    this.calendar.unregisterInteractiveComponent(this);\n  };\n\n  SimpleTimeGrid.prototype.render = function (props) {\n    var dateProfile = props.dateProfile,\n        dayTable = props.dayTable;\n    var dayRanges = this.dayRanges = this.buildDayRanges(dayTable, dateProfile, this.dateEnv);\n    this.timeGrid.receiveProps(__assign({}, this.slicer.sliceProps(props, dateProfile, null, this.timeGrid, dayRanges), {\n      dateProfile: dateProfile,\n      cells: dayTable.cells[0]\n    }));\n  };\n\n  SimpleTimeGrid.prototype.renderNowIndicator = function (date) {\n    this.timeGrid.renderNowIndicator(this.slicer.sliceNowDate(date, this.timeGrid, this.dayRanges), date);\n  };\n\n  SimpleTimeGrid.prototype.buildPositionCaches = function () {\n    this.timeGrid.buildPositionCaches();\n  };\n\n  SimpleTimeGrid.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.timeGrid.positionToHit(positionLeft, positionTop);\n\n    if (rawHit) {\n      return {\n        component: this.timeGrid,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n  };\n\n  return SimpleTimeGrid;\n}(DateComponent);\n\nfunction buildDayRanges(dayTable, dateProfile, dateEnv) {\n  var ranges = [];\n\n  for (var _i = 0, _a = dayTable.headerDates; _i < _a.length; _i++) {\n    var date = _a[_i];\n    ranges.push({\n      start: dateEnv.add(date, dateProfile.minTime),\n      end: dateEnv.add(date, dateProfile.maxTime)\n    });\n  }\n\n  return ranges;\n}\n\nvar TimeGridSlicer =\n/** @class */\nfunction (_super) {\n  __extends(TimeGridSlicer, _super);\n\n  function TimeGridSlicer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TimeGridSlicer.prototype.sliceRange = function (range, dayRanges) {\n    var segs = [];\n\n    for (var col = 0; col < dayRanges.length; col++) {\n      var segRange = intersectRanges(range, dayRanges[col]);\n\n      if (segRange) {\n        segs.push({\n          start: segRange.start,\n          end: segRange.end,\n          isStart: segRange.start.valueOf() === range.start.valueOf(),\n          isEnd: segRange.end.valueOf() === range.end.valueOf(),\n          col: col\n        });\n      }\n    }\n\n    return segs;\n  };\n\n  return TimeGridSlicer;\n}(Slicer);\n\nvar TimeGridView$1 =\n/** @class */\nfunction (_super) {\n  __extends(TimeGridView, _super);\n\n  function TimeGridView(_context, viewSpec, dateProfileGenerator, parentEl) {\n    var _this = _super.call(this, _context, viewSpec, dateProfileGenerator, parentEl) || this;\n\n    _this.buildDayTable = memoize(buildDayTable);\n\n    if (_this.opt('columnHeader')) {\n      _this.header = new DayHeader(_this.context, _this.el.querySelector('.fc-head-container'));\n    }\n\n    _this.simpleTimeGrid = new SimpleTimeGrid(_this.context, _this.timeGrid);\n\n    if (_this.dayGrid) {\n      _this.simpleDayGrid = new SimpleDayGrid(_this.context, _this.dayGrid);\n    }\n\n    return _this;\n  }\n\n  TimeGridView.prototype.destroy = function () {\n    _super.prototype.destroy.call(this);\n\n    if (this.header) {\n      this.header.destroy();\n    }\n\n    this.simpleTimeGrid.destroy();\n\n    if (this.simpleDayGrid) {\n      this.simpleDayGrid.destroy();\n    }\n  };\n\n  TimeGridView.prototype.render = function (props) {\n    _super.prototype.render.call(this, props); // for flags for updateSize\n\n\n    var dateProfile = this.props.dateProfile;\n    var dayTable = this.buildDayTable(dateProfile, this.dateProfileGenerator);\n    var splitProps = this.splitter.splitProps(props);\n\n    if (this.header) {\n      this.header.receiveProps({\n        dateProfile: dateProfile,\n        dates: dayTable.headerDates,\n        datesRepDistinctDays: true,\n        renderIntroHtml: this.renderHeadIntroHtml\n      });\n    }\n\n    this.simpleTimeGrid.receiveProps(__assign({}, splitProps['timed'], {\n      dateProfile: dateProfile,\n      dayTable: dayTable\n    }));\n\n    if (this.simpleDayGrid) {\n      this.simpleDayGrid.receiveProps(__assign({}, splitProps['allDay'], {\n        dateProfile: dateProfile,\n        dayTable: dayTable,\n        nextDayThreshold: this.nextDayThreshold,\n        isRigid: false\n      }));\n    }\n  };\n\n  TimeGridView.prototype.renderNowIndicator = function (date) {\n    this.simpleTimeGrid.renderNowIndicator(date);\n  };\n\n  return TimeGridView;\n}(TimeGridView);\n\nfunction buildDayTable(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeries(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTable(daySeries, false);\n}\n\nvar main = createPlugin({\n  defaultView: 'timeGridWeek',\n  views: {\n    timeGrid: {\n      class: TimeGridView$1,\n      allDaySlot: true,\n      slotDuration: '00:30:00',\n      slotEventOverlap: true // a bad name. confused with overlap/constraint system\n\n    },\n    timeGridDay: {\n      type: 'timeGrid',\n      duration: {\n        days: 1\n      }\n    },\n    timeGridWeek: {\n      type: 'timeGrid',\n      duration: {\n        weeks: 1\n      }\n    }\n  }\n});\nexport default main;\nexport { TimeGridView as AbstractTimeGridView, TimeGrid, TimeGridSlicer, TimeGridView$1 as TimeGridView, buildDayRanges, buildDayTable };","map":null,"metadata":{},"sourceType":"module"}